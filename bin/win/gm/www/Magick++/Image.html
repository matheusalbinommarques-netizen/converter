<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="en" name="language">
	<title>Magick::Image Class</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link media="screen" href="../docutils-articles.css" type="text/css" rel="stylesheet">

</head>

<body>

<div class="banner">
<img src="../images/gm-107x76.png" alt="GraphicMagick logo" width="107" height="76" />
<span class="title">GraphicsMagick</span>
<form action="http://www.google.com/search">
  <input type="hidden" name="domains" value="www.graphicsmagick.org" />
  <input type="hidden" name="sitesearch" value="www.graphicsmagick.org" />
<span class="nowrap"><input type="text" name="q" size="25" maxlength="255" />&nbsp;<input type="submit" name="sa" value="Search" /></span>
</form>
</div>


<div class="navmenu">
<ul>
  <li><a href="../index.html">Home</a></li>
  <li><a href="../project.html">Project</a></li>
  <li><a href="../download.html">Download</a></li>
  <li><a href="../README.html">Install</a></li>
  <li><a href="../Hg.html">Source</a></li>
  <li><a href="../NEWS.html">News</a> </li>
  <li><a href="../utilities.html">Utilities</a></li>
  <li><a href="../programming.html">Programming</a></li>
  <li><a href="../reference.html">Reference</a></li>
</ul>
</div>

<main id="magick-image-class">
<h1 class="title">Magick::Image Class</h1>
<!-- -*- mode: rst -*- -->
<!-- This text is in reStucturedText format, so it may look a bit odd. -->
<!-- See http://docutils.sourceforge.net/rst.html for details. -->
<nav class="contents" id="contents" role="doc-toc">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#blobs" id="toc-entry-2">BLOBs</a></p></li>
<li><p><a class="reference internal" href="#construct-an-image" id="toc-entry-3">Construct An Image</a></p></li>
<li><p><a class="reference internal" href="#read-or-write-an-image" id="toc-entry-4">Read Or Write An Image</a></p></li>
<li><p><a class="reference internal" href="#manipulate-an-image" id="toc-entry-5">Manipulate An Image</a></p></li>
<li><p><a class="reference internal" href="#set-get-image-attributes" id="toc-entry-6">Set/Get Image Attributes</a></p></li>
<li><p><a class="reference internal" href="#low-level-image-pixel-access" id="toc-entry-7">Low-Level Image Pixel Access</a></p></li>
<li><p><a class="reference internal" href="#explicit-logging-configuration-and-callbacks" id="toc-entry-8">Explicit Logging Configuration And Callbacks</a></p></li>
</ul>
</nav>
<section id="introduction">
<h1><a class="toc-backref" href="#toc-entry-1" role="doc-backlink">Introduction</a></h1>
<p>Image is the primary object in Magick++ and represents a single image
frame (see <a class="reference external" href="ImageDesign.html">image design</a>). The <a class="reference external" href="STL.html">STL</a> interface must be used to
operate on image sequences or images (e.g. of format GIF, TIFF, MIFF,
Postscript, &amp; MNG) which are comprized of multiple image
frames. Individual frames of a multi-frame image may be requested by
adding array-style notation to the end of the file name
(e.g. &quot;animation.gif[3]&quot; retrieves the fourth frame of a GIF
animation.  Various image manipulation operations may be applied to
the image. Attributes may be set on the image to influence the
operation of the manipulation operations. The <a class="reference external" href="Pixels.html">Pixels</a> class provides
low-level access to image pixels. As a convenience, including
&lt;Magick++.h&gt; is sufficient in order to use the complete Magick++
API. The Magick++ API is enclosed within the Magick namespace so you
must either add the prefix &quot; Magick:: &quot; to each class/enumeration name
or add the statement &quot; using namespace Magick;&quot; after including the
Magick++.h header.</p>
<p>The InitializeMagick() function <em>MUST</em> be invoked before constructing
any Magick++ objects.  This used to be optional, but now it is
absolutely required.  This function initalizes semaphores and
configuration information necessary for the software to work
correctly.  Failing to invoke InitializeMagick() will lead to a
program crash or thrown assertion.  If the program resides in the same
directory as the GraphicsMagick files, then argv[0] may be passed as
an argument so that GraphicsMagick knows where its files reside,
otherwise NULL may be passed and GraphicsMagick will try to use other
means (if necessary).  Even if an argument is passed, GraphicsMagick
may use more reliable location information gleaned from the operating
system, depending on build configuration.</p>
<p>The preferred way to allocate Image objects is via automatic
allocation (on the stack). There is no concern that allocating Image
objects on the stack will excessively enlarge the stack since Magick++
allocates all large data objects (such as the actual image data) from
the heap. Use of automatic allocation is preferred over explicit
allocation (via new) since it is much less error prone and allows use
of C++ scoping rules to avoid memory leaks. Use of automatic
allocation allows Magick++ objects to be assigned and copied just like
the C++ intrinsic data types (e.g. 'int '), leading to clear and easy
to read code. Use of automatic allocation leads to naturally
exception-safe code since if an exception is thrown, the object is
automatically deallocated once the stack unwinds past the scope of the
allocation (not the case for objects allocated via new ).</p>
<p>Image is very easy to use. For example, here is a the source to a
program which reads an image, crops it, and writes it to a new file
(the exception handling is optional but strongly recommended):</p>
<pre class="literal-block">#include &lt;Magick++.h&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace Magick;
int main(int argc,char **argv)
{
  // Initialize/Deinitialize GraphicsMagick (scope based).
  // Can pass NULL if argv is not available.
  InitializeMagickSentinel sentinel(*argv);

  // Construct the image object. Seperating image construction from the
  // the read operation ensures that a failure to read the image file
  // doesn't render the image object useless.
  Image image;

  try {
    // Determine if Warning exceptions are thrown.
    // Use is optional.  Set to true to block Warning exceptions.
    image.quiet( false );

    // Read a file into image object
    image.read( &quot;girl.gif&quot; );

    // Crop the image to specified size (width, height, xOffset, yOffset)
    image.crop( Geometry(100,100, 100, 100) );

    // Write the image to a file
    image.write( &quot;x.gif&quot; );
  }
  catch( Exception &amp;error_ )
    {
      cout &lt;&lt; &quot;Caught exception: &quot; &lt;&lt; error_.what() &lt;&lt; endl;
      return EXIT_FAILURE;
    }
  return EXIT_SUCCESS;
}</pre>
<p>Note that if InitializeMagickSentinel() is used, then the
implementation is automatically de-initialized (avoiding the
appearance of possible &quot;leaks&quot;) due to a return from main(), or if an
uncaught exception causes the program to exit.  If mechanisms such as
exit() are used, then use InitializeMagick(*argv) and DestroyMagick().</p>
<p>The following is the source to a program which illustrates the use of
Magick++'s efficient reference-counted assignment and copy-constructor
operations which minimize use of memory and eliminate unncessary copy
operations (allowing Image objects to be efficiently assigned, and
copied into containers).  The program accomplishes the following:</p>
<ol class="arabic simple">
<li><p>Read master image.</p></li>
<li><p>Assign master image to second image.</p></li>
<li><p>Zoom second image to the size 640x480.</p></li>
<li><p>Assign master image to a third image.</p></li>
<li><p>Zoom third image to the size 800x600.</p></li>
<li><p>Write the second image to a file.</p></li>
<li><p>Write the third image to a file.</p></li>
</ol>
<pre class="literal-block">#include &lt;Magick++.h&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace Magick;
int main(int argc,char **argv)
{
    // Initialize/Deinitialize GraphicsMagick (scope based).
    InitializeMagickSentinel sentinel(*argv);
    Image master(&quot;horse.jpg&quot;);
    Image second = master;
    second.zoom(&quot;640x480&quot;);
    Image third = master;
    third.zoom(&quot;800x600&quot;);
    second.write(&quot;horse640x480.jpg&quot;);
    third.write(&quot;horse800x600.jpg&quot;);
    return EXIT_SUCCESS;
}</pre>
<p>During the entire operation, a maximum of three images exist in memory
and the image data is never copied.</p>
<p>The following is the source for another simple program which creates a
100 by 100 pixel white image with a red pixel in the center and writes
it to a file:</p>
<pre class="literal-block">#include &lt;Magick++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;
using namespace Magick;
int main(int argc,char **argv)
{
    InitializeMagick(*argv);
    Image image( &quot;100x100&quot;, &quot;white&quot; );
    image.pixelColor( 49, 49, &quot;red&quot; );
    image.write( &quot;red_pixel.png&quot; );
    DestroyMagick();
    return EXIT_SUCCESS;
}</pre>
<p>If you wanted to change the color image to grayscale, you could add
the lines:</p>
<pre class="literal-block">image.quantizeColorSpace( GRAYColorspace );
image.quantizeColors( 256 );
image.quantize( );</pre>
<p>or, more simply:</p>
<pre class="literal-block">image.type( GrayscaleType );</pre>
<p>prior to writing the image.</p>
</section>
<section id="blobs">
<h1><a class="toc-backref" href="#toc-entry-2" role="doc-backlink">BLOBs</a></h1>
<p>While encoded images (e.g. JPEG) are most often written-to and
read-from a disk file, encoded images may also reside in
memory. Encoded images in memory are known as BLOBs (Binary Large
OBjects) and may be represented using the <a class="reference external" href="Blob.html">Blob</a> class. The encoded
image may be initially placed in memory by reading it directly from a
file, reading the image from a database, memory-mapped from a disk
file, or could be written to memory by Magick++. Once the encoded
image has been placed within a <a class="reference external" href="Blob.html">Blob</a>, it may be read into a Magick++
Image via a constructor or read() . Likewise, a Magick++ image may be
written to a <a class="reference external" href="Blob.html">Blob</a> via write().</p>
<p>An example of using Image to write to a <a class="reference external" href="Blob.html">Blob</a> follows:</p>
<pre class="literal-block">#include &lt;Magick++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;
using namespace Magick;
int main(int argc,char **argv)
{
    InitializeMagickSentinel sentinel(*argv);

    // Read GIF file from disk
    Image image( &quot;giraffe.gif&quot; );

    // Write to BLOB in JPEG format
    Blob blob;
    image.magick( &quot;JPEG&quot; ) // Set JPEG output format
    image.write( &amp;blob );

    [ Use BLOB data (in JPEG format) here ]

    return EXIT_SUCCESS;
}</pre>
<p>likewise, to read an image from a <a class="reference external" href="Blob.html">Blob</a>, you could use one of the
following examples:</p>
<p>[ Entry condition for the following examples is that data is pointer
to encoded image data and length represents the size of the data ]</p>
<pre class="literal-block">Blob blob( data, length );
Image image( blob );</pre>
<p>or</p>
<pre class="literal-block">Blob blob( data, length );
Image image;
image.read( blob);</pre>
<p>Some images do not contain their size or format so the size and format
must be specified in advance:</p>
<pre class="literal-block">Blob blob( data, length );
Image image;
image.size( &quot;640x480&quot;)
image.magick( &quot;RGBA&quot; );
image.read( blob);</pre>
</section>
<section id="construct-an-image">
<h1><a class="toc-backref" href="#toc-entry-3" role="doc-backlink">Construct An Image</a></h1>
<p>An Image may be constructed in a number of ways. It may be constructed
from a file, a URL, or an encoded image (e.g. JPEG) contained in an
in-memory <a class="reference external" href="Blob.html">Blob</a> . The following Image constructors and assignment
operators are available:</p>
<p>Construct from image file or image specification:</p>
<pre class="literal-block">Image( const std::string &amp;imageSpec_ )</pre>
<p>Construct a blank image canvas of specified size and <a class="reference external" href="Color.html">color</a>:</p>
<pre class="literal-block">Image( const Geometry &amp;size_, const Color &amp;color_ )</pre>
<p>Construct Image from in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">Image ( const Blob &amp;blob_ )</pre>
<p>Construct Image of specified size from in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">Image ( const Blob &amp;blob_, const Geometry &amp;size_ )</pre>
<p>Construct Image of specified size and depth from in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">Image ( const Blob &amp;blob_, const Geometry &amp;size,
        const unsigned int depth )</pre>
<p>Construct Image of specified size, depth, and format from in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">Image ( const Blob &amp;blob_, const Geometry &amp;size,
        const unsigned int depth_,
        const std::string &amp;magick_ )</pre>
<p>Construct Image of specified size, and format from in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">Image ( const Blob &amp;blob_, const Geometry &amp;size,
        const std::string &amp;magick_ )</pre>
<p>Construct an image based on an array of raw pixels, of specified type
and mapping, in memory:</p>
<pre class="literal-block">Image ( const unsigned int width_,
        const unsigned int height_,
        const std::string &amp;map_,
        const StorageType type_,
        const void *pixels_ )</pre>
<p>Default constructor:</p>
<pre class="literal-block">Image( void )</pre>
<p>Copy constructor:</p>
<pre class="literal-block">Image ( const Image &amp; image_ )</pre>
<p>Assignment operator:</p>
<pre class="literal-block">Image&amp; operator= ( const Image &amp;image_ )</pre>
</section>
<section id="read-or-write-an-image">
<h1><a class="toc-backref" href="#toc-entry-4" role="doc-backlink">Read Or Write An Image</a></h1>
<nav class="contents local" id="topic-1">
<ul class="simple">
<li><p><a class="reference internal" href="#ping" id="toc-entry-9">ping</a></p></li>
<li><p><a class="reference internal" href="#read" id="toc-entry-10">read</a></p></li>
<li><p><a class="reference internal" href="#write" id="toc-entry-11">write</a></p></li>
</ul>
</nav>
<section id="ping">
<h2><a class="toc-backref" href="#toc-entry-9" role="doc-backlink">ping</a></h2>
<p>Ping is similar to <a class="reference internal" href="#read">read</a> except only enough of the image is read to
determine the image columns, rows, and filesize.  Access the
columns(), rows(), and fileSize() attributes after invoking ping.
Other attributes may also be available.  The image pixels are not
valid after calling ping:</p>
<pre class="literal-block">void            ping ( const std::string &amp;imageSpec_ )</pre>
<p>Ping is similar to read except only enough of the image is read
to determine the image columns, rows, and filesize.  Access the
columns(), rows(), and fileSize() attributes after invoking
ping.  The image pixels are not valid after calling ping:</p>
<pre class="literal-block">void            ping ( const Blob &amp;blob_ )</pre>
</section>
<section id="read">
<h2><a class="toc-backref" href="#toc-entry-10" role="doc-backlink">read</a></h2>
<p>Read single image frame into current object.  Use <a class="reference internal" href="#ping">ping</a> instead if you
want to obtain the basic attributes of the image without reading the
whole file/blob:</p>
<pre class="literal-block">void            read ( const std::string &amp;imageSpec_ )</pre>
<p>Read single image frame of specified size into current object:</p>
<pre class="literal-block">void            read ( const Geometry &amp;size_,
                       const std::string &amp;imageSpec_ )</pre>
<p>Read single image frame from in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">void            read ( const Blob        &amp;blob_ )</pre>
<p>Read single image frame of specified size from in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">void            read ( const Blob        &amp;blob_,
                       const Geometry    &amp;size_ )</pre>
<p>Read single image frame of specified size and depth from in-memory
<a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">void            read ( const Blob         &amp;blob_,
                       const Geometry     &amp;size_,
                       const unsigned int depth_ )</pre>
<p>Read single image frame of specified size, depth, and format from
in-memory <a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">void            read ( const Blob         &amp;blob_,
                       const Geometry     &amp;size_,
                       const unsigned int depth_,
                       const std::string  &amp;magick_ )</pre>
<p>Read single image frame of specified size, and format from in-memory
<a class="reference external" href="Blob.html">Blob</a>:</p>
<pre class="literal-block">void            read ( const Blob         &amp;blob_,
                       const Geometry     &amp;size_,
                       const std::string  &amp;magick_ )</pre>
<p>Read single image frame from an array of raw pixels, with
specified storage type (ConstituteImage), e.g.
<span class="docutils literal">image.read( 640, 480, &quot;RGB&quot;, 0, pixels )</span>:</p>
<pre class="literal-block">void            read ( const unsigned int width_,
                       const unsigned int height_,
                       const std::string &amp;map_,
                       const StorageType  type_,
                       const void        *pixels_ )</pre>
</section>
<section id="write">
<h2><a class="toc-backref" href="#toc-entry-11" role="doc-backlink">write</a></h2>
<p>Write single image frame to a file:</p>
<pre class="literal-block">void            write ( const std::string &amp;imageSpec_ )</pre>
<p>Write single image frame to in-memory <a class="reference external" href="Blob.html">Blob</a>, with optional format and
adjoin parameters:</p>
<pre class="literal-block">void            write ( Blob *blob_ )

void            write ( Blob *blob_,
                        const std::string &amp;magick_ )

void            write ( Blob *blob_,
                        const std::string &amp;magick_,
                        const unsigned int depth_ )</pre>
<p>Write single image frame to an array of pixels with storage type
specified by user (DispatchImage), e.g.  <span class="docutils literal">image.write( 0, 0, 640, 1, &quot;RGB&quot;, 0, pixels )</span>:</p>
<pre class="literal-block">void            write ( const int x_,
                        const int y_,
                        const unsigned int columns_,
                        const unsigned int rows_,
                        const std::string&amp; map_,
                        const StorageType type_,
                        void *pixels_ )</pre>
</section>
</section>
<section id="manipulate-an-image">
<h1><a class="toc-backref" href="#toc-entry-5" role="doc-backlink">Manipulate An Image</a></h1>
<p>Image supports access to all the single-image (versus image-list)
manipulation operations provided by the GraphicsMagick library. If you
must process a multi-image file (such as an animation), the <a class="reference external" href="STL.html">STL</a>
interface , which provides a multi-image abstraction on top of Image,
must be used.</p>
<p>Image manipulation methods are very easy to use.  For example:</p>
<pre class="literal-block">Image image;
image.read(&quot;myImage.tiff&quot;);
image.addNoise(GaussianNoise);
image.write(&quot;myImage.tiff&quot;);</pre>
<p>adds gaussian noise to the image file &quot;myImage.tiff&quot;.</p>
<p>The following image manipulation methods are available:</p>
<nav class="contents local" id="topic-2">
<ul class="simple">
<li><p><a class="reference internal" href="#adaptivethreshold" id="toc-entry-12">adaptiveThreshold</a></p></li>
<li><p><a class="reference internal" href="#addnoise" id="toc-entry-13">addNoise</a></p></li>
<li><p><a class="reference internal" href="#addnoisechannel" id="toc-entry-14">addNoiseChannel</a></p></li>
<li><p><a class="reference internal" href="#affinetransform" id="toc-entry-15">affineTransform</a></p></li>
<li><p><a class="reference internal" href="#annotate" id="toc-entry-16">annotate</a></p></li>
<li><p><a class="reference internal" href="#autoorient" id="toc-entry-17">autoOrient</a></p></li>
<li><p><a class="reference internal" href="#blur" id="toc-entry-18">blur</a></p></li>
<li><p><a class="reference internal" href="#blurchannel" id="toc-entry-19">blurChannel</a></p></li>
<li><p><a class="reference internal" href="#border" id="toc-entry-20">border</a></p></li>
<li><p><a class="reference internal" href="#cdl" id="toc-entry-21">cdl</a></p></li>
<li><p><a class="reference internal" href="#channel" id="toc-entry-22">channel</a></p></li>
<li><p><a class="reference internal" href="#channeldepth" id="toc-entry-23">channelDepth</a></p></li>
<li><p><a class="reference internal" href="#charcoal" id="toc-entry-24">charcoal</a></p></li>
<li><p><a class="reference internal" href="#chop" id="toc-entry-25">chop</a></p></li>
<li><p><a class="reference internal" href="#colorize" id="toc-entry-26">colorize</a></p></li>
<li><p><a class="reference internal" href="#colormatrix" id="toc-entry-27">colorMatrix</a></p></li>
<li><p><a class="reference internal" href="#comment" id="toc-entry-28">comment</a></p></li>
<li><p><a class="reference internal" href="#compare" id="toc-entry-29">compare</a></p></li>
<li><p><a class="reference internal" href="#composite" id="toc-entry-30">composite</a></p></li>
<li><p><a class="reference internal" href="#contrast" id="toc-entry-31">contrast</a></p></li>
<li><p><a class="reference internal" href="#convolve" id="toc-entry-32">convolve</a></p></li>
<li><p><a class="reference internal" href="#crop" id="toc-entry-33">crop</a></p></li>
<li><p><a class="reference internal" href="#cyclecolormap" id="toc-entry-34">cycleColormap</a></p></li>
<li><p><a class="reference internal" href="#despeckle" id="toc-entry-35">despeckle</a></p></li>
<li><p><a class="reference internal" href="#display" id="toc-entry-36">display</a></p></li>
<li><p><a class="reference internal" href="#draw" id="toc-entry-37">draw</a></p></li>
<li><p><a class="reference internal" href="#edge" id="toc-entry-38">edge</a></p></li>
<li><p><a class="reference internal" href="#emboss" id="toc-entry-39">emboss</a></p></li>
<li><p><a class="reference internal" href="#enhance" id="toc-entry-40">enhance</a></p></li>
<li><p><a class="reference internal" href="#equalize" id="toc-entry-41">equalize</a></p></li>
<li><p><a class="reference internal" href="#erase" id="toc-entry-42">erase</a></p></li>
<li><p><a class="reference internal" href="#extent" id="toc-entry-43">extent</a></p></li>
<li><p><a class="reference internal" href="#flip" id="toc-entry-44">flip</a></p></li>
<li><p><a class="reference internal" href="#floodfillcolor" id="toc-entry-45">floodFillColor</a></p></li>
<li><p><a class="reference internal" href="#floodfillopacity" id="toc-entry-46">floodFillOpacity</a></p></li>
<li><p><a class="reference internal" href="#floodfilltexture" id="toc-entry-47">floodFillTexture</a></p></li>
<li><p><a class="reference internal" href="#flop" id="toc-entry-48">flop</a></p></li>
<li><p><a class="reference internal" href="#frame" id="toc-entry-49">frame</a></p></li>
<li><p><a class="reference internal" href="#gamma" id="toc-entry-50">gamma</a></p></li>
<li><p><a class="reference internal" href="#gaussianblur" id="toc-entry-51">gaussianBlur</a></p></li>
<li><p><a class="reference internal" href="#gaussianblurchannel" id="toc-entry-52">gaussianBlurChannel</a></p></li>
<li><p><a class="reference internal" href="#implode" id="toc-entry-53">implode</a></p></li>
<li><p><a class="reference internal" href="#haldclut" id="toc-entry-54">haldClut</a></p></li>
<li><p><a class="reference internal" href="#label" id="toc-entry-55">label</a></p></li>
<li><p><a class="reference internal" href="#level" id="toc-entry-56">level</a></p></li>
<li><p><a class="reference internal" href="#levelchannel" id="toc-entry-57">levelChannel</a></p></li>
<li><p><a class="reference internal" href="#magnify" id="toc-entry-58">magnify</a></p></li>
<li><p><a class="reference internal" href="#map" id="toc-entry-59">map</a></p></li>
<li><p><a class="reference internal" href="#mattefloodfill" id="toc-entry-60">matteFloodfill</a></p></li>
<li><p><a class="reference internal" href="#medianfilter" id="toc-entry-61">medianFilter</a></p></li>
<li><p><a class="reference internal" href="#minify" id="toc-entry-62">minify</a></p></li>
<li><p><a class="reference internal" href="#modifyimage" id="toc-entry-63">modifyImage</a></p></li>
<li><p><a class="reference internal" href="#modulate" id="toc-entry-64">modulate</a></p></li>
<li><p><a class="reference internal" href="#motionblur" id="toc-entry-65">motionBlur</a></p></li>
<li><p><a class="reference internal" href="#negate" id="toc-entry-66">negate</a></p></li>
<li><p><a class="reference internal" href="#normalize" id="toc-entry-67">normalize</a></p></li>
<li><p><a class="reference internal" href="#oilpaint" id="toc-entry-68">oilPaint</a></p></li>
<li><p><a class="reference internal" href="#opacity" id="toc-entry-69">opacity</a></p></li>
<li><p><a class="reference internal" href="#opaque" id="toc-entry-70">opaque</a></p></li>
<li><p><a class="reference internal" href="#quantize" id="toc-entry-71">quantize</a></p></li>
<li><p><a class="reference internal" href="#quantumoperator" id="toc-entry-72">quantumOperator</a></p></li>
<li><p><a class="reference internal" href="#process" id="toc-entry-73">process</a></p></li>
<li><p><a class="reference internal" href="#raise" id="toc-entry-74">raise</a></p></li>
<li><p><a class="reference internal" href="#randomthreshold" id="toc-entry-75">randomThreshold</a></p></li>
<li><p><a class="reference internal" href="#randomthresholdchannel" id="toc-entry-76">randomThresholdChannel</a></p></li>
<li><p><a class="reference internal" href="#reducenoise" id="toc-entry-77">reduceNoise</a></p></li>
<li><p><a class="reference internal" href="#resize" id="toc-entry-78">resize</a></p></li>
<li><p><a class="reference internal" href="#roll" id="toc-entry-79">roll</a></p></li>
<li><p><a class="reference internal" href="#rotate" id="toc-entry-80">rotate</a></p></li>
<li><p><a class="reference internal" href="#sample" id="toc-entry-81">sample</a></p></li>
<li><p><a class="reference internal" href="#scale" id="toc-entry-82">scale</a></p></li>
<li><p><a class="reference internal" href="#thumbnail" id="toc-entry-83">thumbnail</a></p></li>
<li><p><a class="reference internal" href="#segment" id="toc-entry-84">segment</a></p></li>
<li><p><a class="reference internal" href="#shade" id="toc-entry-85">shade</a></p></li>
<li><p><a class="reference internal" href="#sharpen" id="toc-entry-86">sharpen</a></p></li>
<li><p><a class="reference internal" href="#sharpenchannel" id="toc-entry-87">sharpenChannel</a></p></li>
<li><p><a class="reference internal" href="#shave" id="toc-entry-88">shave</a></p></li>
<li><p><a class="reference internal" href="#shear" id="toc-entry-89">shear</a></p></li>
<li><p><a class="reference internal" href="#solarize" id="toc-entry-90">solarize</a></p></li>
<li><p><a class="reference internal" href="#spread" id="toc-entry-91">spread</a></p></li>
<li><p><a class="reference internal" href="#stegano" id="toc-entry-92">stegano</a></p></li>
<li><p><a class="reference internal" href="#stereo" id="toc-entry-93">stereo</a></p></li>
<li><p><a class="reference internal" href="#strip" id="toc-entry-94">strip</a></p></li>
<li><p><a class="reference internal" href="#swirl" id="toc-entry-95">swirl</a></p></li>
<li><p><a class="reference internal" href="#texture" id="toc-entry-96">texture</a></p></li>
<li><p><a class="reference internal" href="#threshold" id="toc-entry-97">threshold</a></p></li>
<li><p><a class="reference internal" href="#transform" id="toc-entry-98">transform</a></p></li>
<li><p><a class="reference internal" href="#transparent" id="toc-entry-99">transparent</a></p></li>
<li><p><a class="reference internal" href="#trim" id="toc-entry-100">trim</a></p></li>
<li><p><a class="reference internal" href="#type" id="toc-entry-101">type</a></p></li>
<li><p><a class="reference internal" href="#unsharpmask" id="toc-entry-102">unsharpmask</a></p></li>
<li><p><a class="reference internal" href="#unsharpmaskchannel" id="toc-entry-103">unsharpmaskChannel</a></p></li>
<li><p><a class="reference internal" href="#wave" id="toc-entry-104">wave</a></p></li>
<li><p><a class="reference internal" href="#zoom" id="toc-entry-105">zoom</a></p></li>
</ul>
</nav>
<section id="adaptivethreshold">
<h2><a class="toc-backref" href="#toc-entry-12" role="doc-backlink">adaptiveThreshold</a></h2>
<p>Apply adaptive thresholding to the image (see
<a class="reference external" href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/adpthrsh.htm">http://homepages.inf.ed.ac.uk/rbf/HIPR2/adpthrsh.htm</a>). Adaptive
thresholding is useful if the ideal threshold level is not known in
advance, or if the illumination gradient is not constant across the
image. Adaptive thresholding works by evaulating the mean (average) of
a pixel region (size specified by width and height) and using the mean
as the thresholding value. In order to remove residual noise from the
background, the threshold may be adjusted by subtracting a constant
offset (default zero) from the mean to compute the threshold:</p>
<pre class="literal-block">void            adaptiveThreshold ( const unsigned int width,
                                    const unsigned int height,
                                    const double offset = 0.0 )</pre>
</section>
<section id="addnoise">
<h2><a class="toc-backref" href="#toc-entry-13" role="doc-backlink">addNoise</a></h2>
<p>Add noise to image with the specified noise type:</p>
<pre class="literal-block">void            addNoise ( const NoiseType noiseType_ )</pre>
</section>
<section id="addnoisechannel">
<h2><a class="toc-backref" href="#toc-entry-14" role="doc-backlink">addNoiseChannel</a></h2>
<p>Add noise to an image channel with the specified noise type. The
<cite>channel</cite> parameter specifies the channel to add noise to.  The
<cite>noiseType</cite> parameter specifies the type of noise:</p>
<pre class="literal-block">void            addNoiseChannel ( const ChannelType channel_,
                                  const NoiseType noiseType_)</pre>
</section>
<section id="affinetransform">
<h2><a class="toc-backref" href="#toc-entry-15" role="doc-backlink">affineTransform</a></h2>
<p>Transform image by specified affine (or free transform) matrix:</p>
<pre class="literal-block">void            affineTransform ( const DrawableAffine &amp;affine )</pre>
</section>
<section id="annotate">
<h2><a class="toc-backref" href="#toc-entry-16" role="doc-backlink">annotate</a></h2>
<p>Annotate image (draw text on image)</p>
<p>Gravity effects text placement in bounding area according to these
rules:</p>
<dl class="simple">
<dt>NorthWestGravity</dt>
<dd><p>text bottom-left corner placed at top-left</p>
</dd>
<dt>NorthGravity</dt>
<dd><p>text bottom-center placed at top-center</p>
</dd>
<dt>NorthEastGravity</dt>
<dd><p>text bottom-right corner placed at top-right</p>
</dd>
<dt>WestGravity</dt>
<dd><p>text left-center placed at left-center</p>
</dd>
<dt>CenterGravity</dt>
<dd><p>text center placed at center</p>
</dd>
<dt>EastGravity</dt>
<dd><p>text right-center placed at right-center</p>
</dd>
<dt>SouthWestGravity</dt>
<dd><p>text top-left placed at bottom-left</p>
</dd>
<dt>SouthGravity</dt>
<dd><p>text top-center placed at bottom-center</p>
</dd>
<dt>SouthEastGravity</dt>
<dd><p>text top-right placed at bottom-right</p>
</dd>
</dl>
<p>Annotate using specified text, and placement location:</p>
<pre class="literal-block">void            annotate ( const std::string &amp;text_,
                           const Geometry &amp;location_ )</pre>
<p>Annotate using specified text, bounding area, and placement gravity:</p>
<pre class="literal-block">void            annotate ( const std::string &amp;text_,
                           const Geometry &amp;boundingArea_,
                           const GravityType gravity_ )</pre>
<p>Annotate with text using specified text, bounding area, placement
gravity, and rotation:</p>
<pre class="literal-block">void            annotate ( const std::string &amp;text_,
                           const Geometry &amp;boundingArea_,
                           const GravityType gravity_,
                           const double degrees_ )</pre>
<p>Annotate with text (bounding area is entire image) and placement
gravity:</p>
<pre class="literal-block">void            annotate ( const std::string &amp;text_,
                           const GravityType gravity_ )</pre>
</section>
<section id="autoorient">
<h2><a class="toc-backref" href="#toc-entry-17" role="doc-backlink">autoOrient</a></h2>
<p>Automatically orient image to be right-side up based on its current
orientation attribute.  This allows the image to be viewed correctly
when the orientation attribute is not available, or is not respected:</p>
<pre class="literal-block">void            autoOrient( void )</pre>
</section>
<section id="blur">
<h2><a class="toc-backref" href="#toc-entry-18" role="doc-backlink">blur</a></h2>
<p>Blur an image with the specified blur factor.</p>
<p>The <cite>radius</cite> parameter specifies the radius of the Gaussian, in
pixels, not counting the center pixel.  The <cite>sigma</cite> parameter
specifies the standard deviation of the Laplacian, in pixels:</p>
<pre class="literal-block">void            blur ( const double radius_ = 0.0,
                       const double sigma_ = 1.0  )</pre>
</section>
<section id="blurchannel">
<h2><a class="toc-backref" href="#toc-entry-19" role="doc-backlink">blurChannel</a></h2>
<p>Blur an image channel with the specified blur factor.</p>
<p>The <cite>channel</cite> parameter specifies the channel to modify. The <cite>radius</cite>
parameter specifies the radius of the Gaussian, in pixels, not
counting the center pixel.  The <cite>sigma</cite> parameter specifies the
standard deviation of the Laplacian, in pixels:</p>
<pre class="literal-block">void            blurChannel ( const ChannelType channel_,
                              const double radius_ = 0.0,
                              const double sigma_ = 1.0  )</pre>
</section>
<section id="border">
<h2><a class="toc-backref" href="#toc-entry-20" role="doc-backlink">border</a></h2>
<p>Border image (add border to image).  The <a class="reference external" href="Color.html">color</a> of the border is
specified by the borderColor attribute:</p>
<pre class="literal-block">void            border ( const Geometry &amp;geometry_
                         = borderGeometryDefault )</pre>
</section>
<section id="cdl">
<h2><a class="toc-backref" href="#toc-entry-21" role="doc-backlink">cdl</a></h2>
<p>Bake in the ASC-CDL, which is a convention for the for the exchange of
basic primary color grading information between for the exchange of
basic primary color grading information between equipment and software
from different manufacturers.  It is a useful transform for other
purposes as well:</p>
<blockquote>
<p>void            cdl ( const std::string &amp;cdl_ )</p>
</blockquote>
<p>See <a class="reference external" href="../api/cdl.html#cdlimage">CdlImage</a> for more details on the ASC-CDL.</p>
</section>
<section id="channel">
<h2><a class="toc-backref" href="#toc-entry-22" role="doc-backlink">channel</a></h2>
<p>Extract channel from image. Use this option to extract a particular
channel from the image.  MatteChannel for example, is useful for
extracting the opacity values from an image:</p>
<pre class="literal-block">void            channel ( const ChannelType channel_ )</pre>
</section>
<section id="channeldepth">
<h2><a class="toc-backref" href="#toc-entry-23" role="doc-backlink">channelDepth</a></h2>
<p>Set or obtain modulus channel depth:</p>
<pre class="literal-block">void            channelDepth ( const ChannelType channel_,
                               const unsigned int depth_ )

unsigned int    channelDepth ( const ChannelType channel_ )</pre>
</section>
<section id="charcoal">
<h2><a class="toc-backref" href="#toc-entry-24" role="doc-backlink">charcoal</a></h2>
<p>Charcoal effect image (looks like charcoal sketch).</p>
<p>The <cite>radius</cite> parameter specifies the radius of the Gaussian, in
pixels, not counting the center pixel.  The <cite>sigma</cite> parameter
specifies the standard deviation of the Laplacian, in pixels:</p>
<pre class="literal-block">void            charcoal ( const double radius_ = 0.0,
                           const double sigma_ = 1.0 )</pre>
</section>
<section id="chop">
<h2><a class="toc-backref" href="#toc-entry-25" role="doc-backlink">chop</a></h2>
<p>Chop image (remove vertical or horizontal subregion of image):</p>
<pre class="literal-block">void            chop ( const Geometry &amp;geometry_ )</pre>
</section>
<section id="colorize">
<h2><a class="toc-backref" href="#toc-entry-26" role="doc-backlink">colorize</a></h2>
<p>Colorize image with pen <a class="reference external" href="Color.html">color</a>, using specified percent opacity for
red, green, and blue quantums:</p>
<pre class="literal-block">void            colorize ( const unsigned int opacityRed_,
                           const unsigned int opacityGreen_,
                           const unsigned int opacityBlue_,
                           const Color &amp;penColor_ )</pre>
<p>Colorize image with pen <a class="reference external" href="Color.html">color</a>, using specified percent opacity:</p>
<pre class="literal-block">void            colorize ( const unsigned int opacity_,
                           const Color &amp;penColor_ )</pre>
</section>
<section id="colormatrix">
<h2><a class="toc-backref" href="#toc-entry-27" role="doc-backlink">colorMatrix</a></h2>
<p>Apply a color matrix to the image channels.  The user supplied matrix
may be of order 1 to 5 (1x1 through 5x5):</p>
<pre class="literal-block">void            colorMatrix (const unsigned int order_,
                             const double *color_matrix_)</pre>
<p>See <a class="reference external" href="../api/fx.html#colormatriximage">ColorMatrixImage</a> for more details.</p>
</section>
<section id="comment">
<h2><a class="toc-backref" href="#toc-entry-28" role="doc-backlink">comment</a></h2>
<p>Comment image (add comment string to image). By default, each image is
commented with its file name. Use this method to assign a specific
comment to the image.  Optionally you can include the image filename,
type, width, height, or other image attributes by embedding <a class="reference external" href="FormatCharacters.html">special
format characters</a>:</p>
<pre class="literal-block">void            comment ( const std::string &amp;comment_ )</pre>
</section>
<section id="compare">
<h2><a class="toc-backref" href="#toc-entry-29" role="doc-backlink">compare</a></h2>
<p>Compare current image with another image.  Sets meanErrorPerPixel,
normalizedMaxError, and normalizedMeanError in the current
image. False is returned if the images are identical. An ErrorOption
exception is thrown if the reference image columns, rows, colorspace,
or matte differ from the current image:</p>
<pre class="literal-block">bool            compare ( const Image &amp;reference_ )</pre>
</section>
<section id="composite">
<h2><a class="toc-backref" href="#toc-entry-30" role="doc-backlink">composite</a></h2>
<p>Compose an image onto another at specified x and y offset and using a
specified algorithm:</p>
<pre class="literal-block">void            composite ( const Image &amp;compositeImage_,
                            const int xOffset_,
                            const int yOffset_,
                            const CompositeOperator compose_
                            = InCompositeOp )

void            composite ( const Image &amp;compositeImage_,
                            const Geometry &amp;offset_,
                            const CompositeOperator compose_
                            = InCompositeOp )

void            composite ( const Image &amp;compositeImage_,
                            const GravityType gravity_,
                            const CompositeOperator compose_
                            = InCompositeOp )</pre>
</section>
<section id="contrast">
<h2><a class="toc-backref" href="#toc-entry-31" role="doc-backlink">contrast</a></h2>
<p>Contrast image (enhance intensity differences in image):</p>
<pre class="literal-block">void            contrast ( const unsigned int sharpen_ )</pre>
</section>
<section id="convolve">
<h2><a class="toc-backref" href="#toc-entry-32" role="doc-backlink">convolve</a></h2>
<p>Convolve image.  Applies a user-specified convolution to the image.
The <cite>order</cite> parameter represents the number of columns and rows in the
filter kernel while <cite>kernel</cite> is a two-dimensional array of doubles
representing the convolution kernel to apply:</p>
<pre class="literal-block">void            convolve ( const unsigned int order_,
                           const double *kernel_ )</pre>
</section>
<section id="crop">
<h2><a class="toc-backref" href="#toc-entry-33" role="doc-backlink">crop</a></h2>
<p>Crop image (return subregion of original image):</p>
<pre class="literal-block">void            crop ( const Geometry &amp;geometry_ )</pre>
</section>
<section id="cyclecolormap">
<h2><a class="toc-backref" href="#toc-entry-34" role="doc-backlink">cycleColormap</a></h2>
<p>Cycle (rotate) image colormap:</p>
<pre class="literal-block">void            cycleColormap ( const int amount_ )</pre>
</section>
<section id="despeckle">
<h2><a class="toc-backref" href="#toc-entry-35" role="doc-backlink">despeckle</a></h2>
<p>Despeckle image (reduce speckle noise):</p>
<pre class="literal-block">void            despeckle ( void )</pre>
</section>
<section id="display">
<h2><a class="toc-backref" href="#toc-entry-36" role="doc-backlink">display</a></h2>
<p>Display image on screen. Caution: if an image format is is not
compatible with the display visual (e.g. JPEG on a colormapped
display) then the original image will be altered. Use a copy of the
original if this is a problem:</p>
<blockquote>
<p>void            display ( void )</p>
</blockquote>
</section>
<section id="draw">
<h2><a class="toc-backref" href="#toc-entry-37" role="doc-backlink">draw</a></h2>
<p>Draw shape or text on image using a single <a class="reference external" href="Drawable.html">drawable</a> object:</p>
<pre class="literal-block">void            draw ( const Drawable &amp;drawable_ );</pre>
<p>Draw shapes or text on image using a set of <a class="reference external" href="Drawable.html">Drawable</a> objects
contained in an <a class="reference external" href="STL.html">STL</a> list. Use of this method improves drawing
performance and allows batching draw objects together in a list for
repeated use:</p>
<pre class="literal-block">void            draw ( const std::list&lt;Magick::Drawable&gt; &amp;drawable_ );</pre>
</section>
<section id="edge">
<h2><a class="toc-backref" href="#toc-entry-38" role="doc-backlink">edge</a></h2>
<p>Edge image (hilight edges in image).  The radius is the radius of the
pixel neighborhood.. Specify a radius of zero for automatic radius
selection:</p>
<pre class="literal-block">void            edge ( const double radius_ = 0.0 )</pre>
</section>
<section id="emboss">
<h2><a class="toc-backref" href="#toc-entry-39" role="doc-backlink">emboss</a></h2>
<p>Emboss image (hilight edges with 3D effect).  The <cite>radius</cite> parameter
specifies the radius of the Gaussian, in pixels, not counting the
center pixel.  The <cite>sigma</cite> parameter specifies the standard deviation
of the Laplacian, in pixels:</p>
<pre class="literal-block">void            emboss ( const double radius_ = 0.0,
                         const double sigma_ = 1.0)</pre>
</section>
<section id="enhance">
<h2><a class="toc-backref" href="#toc-entry-40" role="doc-backlink">enhance</a></h2>
<p>Enhance image (minimize noise):</p>
<pre class="literal-block">void            enhance ( void );</pre>
</section>
<section id="equalize">
<h2><a class="toc-backref" href="#toc-entry-41" role="doc-backlink">equalize</a></h2>
<p>Equalize image (histogram equalization):</p>
<pre class="literal-block">void            equalize ( void )</pre>
</section>
<section id="erase">
<h2><a class="toc-backref" href="#toc-entry-42" role="doc-backlink">erase</a></h2>
<p>Set all image pixels to the current background color:</p>
<pre class="literal-block">void            erase ( void )</pre>
</section>
<section id="extent">
<h2><a class="toc-backref" href="#toc-entry-43" role="doc-backlink">extent</a></h2>
<p>Create an image canvas using background color sized according to
geometry and composite existing image on it, with image placement
controlled by gravity.  Parameters are obtained from existing image
properties if they are not specified via a method
parameter. Parameters which are supported by image properties (gravity
and backgroundColor) update those image properties as a side-effect:</p>
<pre class="literal-block">void            extent ( const Geometry &amp;geometry_ )

void            extent ( const Geometry &amp;geometry_,
                         const GravityType &amp;gravity_ )

void            extent ( const Geometry &amp;geometry_,
                         const Color &amp;backgroundColor_ )

void            extent ( const Geometry &amp;geometry_,
                         const Color &amp;backgroundColor_,
                         const GravityType &amp;gravity_ );</pre>
</section>
<section id="flip">
<h2><a class="toc-backref" href="#toc-entry-44" role="doc-backlink">flip</a></h2>
<p>Flip image (reflect each scanline in the vertical direction):</p>
<pre class="literal-block">void            flip ( void )</pre>
</section>
<section id="floodfillcolor">
<h2><a class="toc-backref" href="#toc-entry-45" role="doc-backlink">floodFillColor</a></h2>
<p>Flood-fill <a class="reference external" href="Color.html">color</a> across pixels that match the <a class="reference external" href="Color.html">color</a> of the target
pixel and are neighbors of the target pixel.  Uses current fuzz
setting when determining <a class="reference external" href="Color.html">color</a> match:</p>
<pre class="literal-block">void            floodFillColor( const unsigned int x_,
                                const unsigned int y_,
                                const Color &amp;fillColor_ )

void            floodFillColor( const Geometry &amp;point_,
                                const Color &amp;fillColor_ )</pre>
<p>Flood-fill <a class="reference external" href="Color.html">color</a> across pixels starting at target-pixel and stopping
at pixels matching specified border <a class="reference external" href="Color.html">color</a>.  Uses current fuzz setting
when determining <a class="reference external" href="Color.html">color</a> match:</p>
<pre class="literal-block">void            floodFillColor( const unsigned int x_,
                                const unsigned int y_,
                                const Color &amp;fillColor_,
                                const Color &amp;borderColor_ )

void            floodFillColor( const Geometry &amp;point_,
                                const Color &amp;fillColor_,
                                const Color &amp;borderColor_ )</pre>
</section>
<section id="floodfillopacity">
<h2><a class="toc-backref" href="#toc-entry-46" role="doc-backlink">floodFillOpacity</a></h2>
<p>Flood-fill pixels matching <a class="reference external" href="Color.html">color</a> (within fuzz factor) of target
pixel(x,y) with replacement opacity value using method:</p>
<pre class="literal-block">void            floodFillOpacity ( const unsigned int x_,
                                   const unsigned int y_,
                                   const unsigned int opacity_,
                                   const PaintMethod method_ )</pre>
</section>
<section id="floodfilltexture">
<h2><a class="toc-backref" href="#toc-entry-47" role="doc-backlink">floodFillTexture</a></h2>
<p>Flood-fill texture across pixels that match the <a class="reference external" href="Color.html">color</a> of the
target pixel and are neighbors of the target pixel.
Uses current fuzz setting when determining <a class="reference external" href="Color.html">color</a> match:</p>
<pre class="literal-block">void            floodFillTexture( const unsigned int x_,
                                  const unsigned int y_,
                                  const Image &amp;texture_ )

void            floodFillTexture( const Geometry &amp;point_,
                                  const Image &amp;texture_ )</pre>
<p>Flood-fill texture across pixels starting at target-pixel and
stopping at pixels matching specified border <a class="reference external" href="Color.html">color</a>.
Uses current fuzz setting when determining <a class="reference external" href="Color.html">color</a> match:</p>
<pre class="literal-block">void            floodFillTexture( const unsigned int x_,
                                  const unsigned int y_,
                                  const Image &amp;texture_,
                                  const Color &amp;borderColor_ )

void            floodFillTexture( const Geometry &amp;point_,
                                  const Image &amp;texture_,
                                  const Color &amp;borderColor_ )</pre>
</section>
<section id="flop">
<h2><a class="toc-backref" href="#toc-entry-48" role="doc-backlink">flop</a></h2>
<p>Flop image (reflect each scanline in the horizontal direction):</p>
<pre class="literal-block">void            flop ( void );</pre>
</section>
<section id="frame">
<h2><a class="toc-backref" href="#toc-entry-49" role="doc-backlink">frame</a></h2>
<p>Draw a decorative frame around the image:</p>
<pre class="literal-block">void            frame ( const Geometry &amp;geometry_ = frameGeometryDefault )

void            frame ( const unsigned int width_,
                        const unsigned int height_,
                        const int innerBevel_ = 6,
                        const int outerBevel_ = 6 )</pre>
</section>
<section id="gamma">
<h2><a class="toc-backref" href="#toc-entry-50" role="doc-backlink">gamma</a></h2>
<p>Gamma correct the image or individual image channels:</p>
<pre class="literal-block">void            gamma ( const double gamma_ )

void            gamma ( const double gammaRed_,
                        const double gammaGreen_,
                        const double gammaBlue_ )</pre>
</section>
<section id="gaussianblur">
<h2><a class="toc-backref" href="#toc-entry-51" role="doc-backlink">gaussianBlur</a></h2>
<p>Gaussian blur image.  The number of neighbor pixels to be included in
the convolution mask is specified by <cite>width</cite>. The standard deviation
of the gaussian bell curve is specified by <cite>sigma</cite>:</p>
<pre class="literal-block">void            gaussianBlur ( const double width_, const double sigma_ )</pre>
</section>
<section id="gaussianblurchannel">
<h2><a class="toc-backref" href="#toc-entry-52" role="doc-backlink">gaussianBlurChannel</a></h2>
<p>Gaussian blur image channel.  The number of neighbor pixels to be
included in the convolution mask is specified by <cite>width</cite>. The
standard deviation of the gaussian bell curve is specified by
<cite>sigma</cite>:</p>
<pre class="literal-block">void            gaussianBlurChannel ( const ChannelType channel_,
                                      const double width_,
                                      const double sigma_ )</pre>
</section>
<section id="implode">
<h2><a class="toc-backref" href="#toc-entry-53" role="doc-backlink">implode</a></h2>
<p>Implode image (special effect):</p>
<pre class="literal-block">void            implode ( const double factor_ )</pre>
</section>
<section id="haldclut">
<h2><a class="toc-backref" href="#toc-entry-54" role="doc-backlink">haldClut</a></h2>
<p>Apply a color lookup table (Hald CLUT) to the image:</p>
<pre class="literal-block">void            haldClut ( const Image &amp;clutImage_ )</pre>
<p>See <a class="reference external" href="../api/hclut.html#haldclutimage">HaldClutImage</a> for more details.</p>
</section>
<section id="label">
<h2><a class="toc-backref" href="#toc-entry-55" role="doc-backlink">label</a></h2>
<p>Assign a label to an image. Use this option to assign a specific label
to the image. Optionally you can include the image filename, type,
width, height, or scene number in the label by embedding <a class="reference external" href="FormatCharacters.html">special
format characters</a>. If the first character of string is &#64;, the image
label is read from a file titled by the remaining characters in the
string. When converting to Postscript, use this option to specify a
header string to print above the image:</p>
<pre class="literal-block">void            label ( const std::string &amp;label_ )</pre>
</section>
<section id="level">
<h2><a class="toc-backref" href="#toc-entry-56" role="doc-backlink">level</a></h2>
<p>Level image to increase image contrast, and/or adjust image
gamma. Adjust the levels of the image by scaling the colors falling
between specified white and black points to the full available quantum
range. The parameters provided represent the black, mid (gamma), and
white points.  The black point specifies the darkest color in the
image. Colors darker than the black point are set to zero. Mid point
(gamma) specifies a gamma correction to apply to the image. White
point specifies the lightest color in the image.  Colors brighter than
the white point are set to the maximum quantum value. The black and
white point have the valid range 0 to MaxRGB while mid (gamma) has a
useful range of 0 to ten:</p>
<pre class="literal-block">void            level ( const double black_point,
                        const double white_point,
                        const double mid_point=1.0 )</pre>
</section>
<section id="levelchannel">
<h2><a class="toc-backref" href="#toc-entry-57" role="doc-backlink">levelChannel</a></h2>
<p>Level image channel to increase image contrast, and/or adjust image
gamma. Adjust the levels of the image channel by scaling the colors
falling between specified white and black points to the full available
quantum range. The parameters provided represent the black, mid
(gamma), and white points.  The black point specifies the darkest
color in the image. Colors darker than the black point are set to
zero. Mid point (gamma) specifies a gamma correction to apply to the
image. White point specifies the lightest color in the image.  Colors
brighter than the white point are set to the maximum quantum
value. The black and white point have the valid range 0 to MaxRGB
while mid (gamma) has a useful range of 0 to ten:</p>
<pre class="literal-block">void            levelChannel ( const ChannelType channel,
                               const double black_point,
                               const double white_point,
                               const double mid_point=1.0 )</pre>
</section>
<section id="magnify">
<h2><a class="toc-backref" href="#toc-entry-58" role="doc-backlink">magnify</a></h2>
<p>Magnify image by integral size (double the dimensions):</p>
<pre class="literal-block">void            magnify ( void )</pre>
</section>
<section id="map">
<h2><a class="toc-backref" href="#toc-entry-59" role="doc-backlink">map</a></h2>
<p>Remap image colors with closest color from a reference image. Set
<cite>dither</cite> to true in to apply Floyd/Steinberg error diffusion to the
image. By default, color reduction chooses an optimal set of colors
that best represent the original image. Alternatively, you can choose
a particular set of colors from an image file with this option:</p>
<pre class="literal-block">void            map ( const Image &amp;mapImage_ ,
                      const bool dither_ = false )</pre>
</section>
<section id="mattefloodfill">
<h2><a class="toc-backref" href="#toc-entry-60" role="doc-backlink">matteFloodfill</a></h2>
<p>Floodfill designated area with a replacement opacity value:</p>
<pre class="literal-block">void            matteFloodfill ( const Color &amp;target_ ,
                                 const unsigned int opacity_,
                                 const int x_, const int y_,
                                 const PaintMethod method_ )</pre>
</section>
<section id="medianfilter">
<h2><a class="toc-backref" href="#toc-entry-61" role="doc-backlink">medianFilter</a></h2>
<p>Filter image by replacing each pixel component with the median color
in a circular neighborhood:</p>
<pre class="literal-block">void            medianFilter ( const double radius_ = 0.0 )</pre>
</section>
<section id="minify">
<h2><a class="toc-backref" href="#toc-entry-62" role="doc-backlink">minify</a></h2>
<p>Reduce image by integral (half) size:</p>
<pre class="literal-block">void            minify ( void )</pre>
</section>
<section id="modifyimage">
<h2><a class="toc-backref" href="#toc-entry-63" role="doc-backlink">modifyImage</a></h2>
<p>Prepare to update image (copy if reference &gt; 1). Normally Magick++'s
implicit reference counting takes care of all instance management.  In
the rare case that the automatic instance management does not work,
use this method to assure that there is only one reference to the
image to be modified.  It should be used in the cases where a
GraphicsMagick C function is used directly on an image which may have
multiple references:</p>
<pre class="literal-block">void            modifyImage ( void )</pre>
</section>
<section id="modulate">
<h2><a class="toc-backref" href="#toc-entry-64" role="doc-backlink">modulate</a></h2>
<p>Modulate percent hue, saturation, and brightness of an image.
Modulation of saturation and brightness is as a ratio of the current
value (1.0 for no change). Modulation of hue is an absolute rotation
of -180 degrees to +180 degrees from the current position
corresponding to an argument range of 0 to 2.0 (1.0 for no change):</p>
<pre class="literal-block">void            modulate ( const double brightness_,
                           const double saturation_,
                           const double hue_ )</pre>
</section>
<section id="motionblur">
<h2><a class="toc-backref" href="#toc-entry-65" role="doc-backlink">motionBlur</a></h2>
<p>Motion blur image with specified blur factor. The <cite>radius</cite> parameter
specifies the radius of the Gaussian, in pixels, not counting the
center pixel.  The <cite>sigma</cite> parameter specifies the standard
deviation of the Laplacian, in pixels.  The <cite>angle</cite> parameter
specifies the angle the object appears to be comming from (zero
degrees is from the right):</p>
<pre class="literal-block">void            motionBlur ( const double radius_,
                             const double sigma_,
                             const double angle_ )</pre>
</section>
<section id="negate">
<h2><a class="toc-backref" href="#toc-entry-66" role="doc-backlink">negate</a></h2>
<p>Negate colors in image.  Set <cite>grayscale</cite> to only negate grayscale
values in image:</p>
<pre class="literal-block">void            negate ( const bool grayscale_ = false )</pre>
</section>
<section id="normalize">
<h2><a class="toc-backref" href="#toc-entry-67" role="doc-backlink">normalize</a></h2>
<p>Normalize image (increase contrast by normalizing the pixel values to
span the full range of color values):</p>
<pre class="literal-block">void            normalize ( void )</pre>
</section>
<section id="oilpaint">
<h2><a class="toc-backref" href="#toc-entry-68" role="doc-backlink">oilPaint</a></h2>
<p>Oilpaint image (image looks like an oil painting):</p>
<pre class="literal-block">void            oilPaint ( const double radius_ = 3.0 )</pre>
</section>
<section id="opacity">
<h2><a class="toc-backref" href="#toc-entry-69" role="doc-backlink">opacity</a></h2>
<p>Set or attenuate the opacity channel in the image. If the image pixels
are opaque then they are set to the specified opacity value, otherwise
they are blended with the supplied opacity value.  The value of
<cite>opacity</cite> ranges from 0 (completely opaque) to MaxRGB. The defines
<cite>OpaqueOpacity</cite> and <cite>TransparentOpacity</cite> are available to specify
completely opaque or completely transparent, respectively:</p>
<pre class="literal-block">void            opacity ( const unsigned int opacity_ )</pre>
</section>
<section id="opaque">
<h2><a class="toc-backref" href="#toc-entry-70" role="doc-backlink">opaque</a></h2>
<p>Change <a class="reference external" href="Color.html">color</a> of specified opaque pixel to specified pen <a class="reference external" href="Color.html">color</a>:</p>
<pre class="literal-block">void            opaque ( const Color &amp;opaqueColor_,
                         const Color &amp;penColor_ )</pre>
</section>
<section id="quantize">
<h2><a class="toc-backref" href="#toc-entry-71" role="doc-backlink">quantize</a></h2>
<p>Quantize image (reduce number of colors). Set <cite>measureError</cite> to true
in order to calculate error attributes:</p>
<pre class="literal-block">void            quantize ( const bool measureError_ = false )</pre>
</section>
<section id="quantumoperator">
<h2><a class="toc-backref" href="#toc-entry-72" role="doc-backlink">quantumOperator</a></h2>
<p>Apply an arithmetic or bitwise operator to the image pixel quantums:</p>
<pre class="literal-block">void            quantumOperator ( const ChannelType channel_,
                                  const QuantumOperator operator_,
                                  double rvalue_)

void            quantumOperator ( const int x_,const int y_,
                                  const unsigned int columns_,
                                  const unsigned int rows_,
                                  const ChannelType channel_,
                                  const QuantumOperator operator_,
                                  const double rvalue_)</pre>
</section>
<section id="process">
<h2><a class="toc-backref" href="#toc-entry-73" role="doc-backlink">process</a></h2>
<p>Execute a named process module using an argc/argv syntax similar to
that accepted by a C 'main' routine. An exception is thrown if the
requested process module doesn't exist, fails to load, or fails during
execution:</p>
<pre class="literal-block">void            process ( std::string name_,
                          const int argc_,
                          char **argv_ )</pre>
</section>
<section id="raise">
<h2><a class="toc-backref" href="#toc-entry-74" role="doc-backlink">raise</a></h2>
<p>Raise image (lighten or darken the edges of an image to give a 3-D
raised or lowered effect):</p>
<pre class="literal-block">void            raise ( const Geometry &amp;geometry_ = &quot;6x6+0+0&quot;,
                        const bool raisedFlag_ = false )</pre>
</section>
<section id="randomthreshold">
<h2><a class="toc-backref" href="#toc-entry-75" role="doc-backlink">randomThreshold</a></h2>
<p>Random threshold image.</p>
<p>Changes the value of individual pixels based on the intensity
of each pixel compared to a random threshold.  The result is a
low-contrast, two color image.  The <cite>thresholds</cite> argument is a
geometry containing LOWxHIGH thresholds.  If the string
contains 2x2, 3x3, or 4x4, then an ordered dither of order 2,
3, or 4 will be performed instead.  If a <cite>channel</cite> argument is
specified then only the specified channel is altered.  This is
a very fast alternative to 'quantize' based dithering:</p>
<pre class="literal-block">void            randomThreshold( const Geometry &amp;thresholds_ )</pre>
</section>
<section id="randomthresholdchannel">
<h2><a class="toc-backref" href="#toc-entry-76" role="doc-backlink">randomThresholdChannel</a></h2>
<p>Random threshold image channel.</p>
<p>Changes the value of individual pixels based on the intensity of each
pixel compared to a random threshold.  The result is a low-contrast,
two color image.  The <cite>thresholds</cite> argument is a geometry containing
LOWxHIGH thresholds.  If the string contains 2x2, 3x3, or 4x4, then an
ordered dither of order 2, 3, or 4 will be performed instead.  If a
<cite>channel</cite> argument is specified then only the specified channel is
altered.  This is a very fast alternative to 'quantize' based
dithering:</p>
<pre class="literal-block">void            randomThresholdChannel( const Geometry &amp;thresholds_,
                                        const ChannelType channel_ )</pre>
</section>
<section id="reducenoise">
<h2><a class="toc-backref" href="#toc-entry-77" role="doc-backlink">reduceNoise</a></h2>
<p>Reduce noise in image using a noise peak elimination filter:</p>
<pre class="literal-block">void            reduceNoise ( void )

void            reduceNoise ( const double order_ )</pre>
</section>
<section id="resize">
<h2><a class="toc-backref" href="#toc-entry-78" role="doc-backlink">resize</a></h2>
<p>Resize image, specifying geometry, filter, and blur (blur &gt; 1.0 is
more blurry and &lt; 1.0 is sharper):</p>
<pre class="literal-block">void            resize ( const Geometry &amp;geometry_,
                         const FilterTypes filterType_,
                         const double blur_ )</pre>
<p>Resize image, specifying geometry and filter, with blur using Image
default:</p>
<pre class="literal-block">void            resize ( const Geometry &amp;geometry_,
                         const FilterTypes filterType_ )</pre>
<p>Resize image, specifying only geometry, with filter and blur obtained
from Image default.  Provides the same result as the <cite>zoom</cite> method:</p>
<pre class="literal-block">void            resize ( const Geometry &amp;geometry_ );</pre>
</section>
<section id="roll">
<h2><a class="toc-backref" href="#toc-entry-79" role="doc-backlink">roll</a></h2>
<p>Roll image (rolls image vertically and horizontally) by specified
number of columnms and rows):</p>
<pre class="literal-block">void            roll ( const Geometry &amp;roll_ )

void            roll ( const unsigned int columns_,
                       const unsigned int rows_ )</pre>
</section>
<section id="rotate">
<h2><a class="toc-backref" href="#toc-entry-80" role="doc-backlink">rotate</a></h2>
<p>Rotate image counter-clockwise by specified number of degrees:</p>
<pre class="literal-block">void            rotate ( const double degrees_ )</pre>
</section>
<section id="sample">
<h2><a class="toc-backref" href="#toc-entry-81" role="doc-backlink">sample</a></h2>
<p>Resize image by using pixel sampling algorithm:</p>
<pre class="literal-block">void            sample ( const Geometry &amp;geometry_ )</pre>
</section>
<section id="scale">
<h2><a class="toc-backref" href="#toc-entry-82" role="doc-backlink">scale</a></h2>
<p>Resize image by using simple ratio algorithm which provides good
quality:</p>
<pre class="literal-block">void            scale ( const Geometry &amp;geometry_ )</pre>
</section>
<section id="thumbnail">
<h2><a class="toc-backref" href="#toc-entry-83" role="doc-backlink">thumbnail</a></h2>
<p>Resize image using several algorithms to make smaller images very
quickly.  This is very useful to create thumbnails from large images
but usually works well for any image resizing purpose:</p>
<pre class="literal-block">void            thumbnail ( const Geometry &amp;geometry_ );</pre>
</section>
<section id="segment">
<h2><a class="toc-backref" href="#toc-entry-84" role="doc-backlink">segment</a></h2>
<p>Segment (coalesce similar image components) by analyzing the
histograms of the color components and identifying units that are
homogeneous with the fuzzy c-means technique.  A histogram is built
for the image.  This histogram is filtered to reduce noise and a
second derivative of the histogram plot is built and used to identify
potential cluster colors (peaks in the histogram).  The cluster colors
are then validated by scanning through all of the pixels to see how
many pixels fall within each cluster.  Some candidate cluster colors
may not match any of the image pixels at all and should be discarded.
Specify <cite>clusterThreshold</cite>, as the number of pixels matching a cluster
color in order for the cluster to be considered
valid. <cite>SmoothingThreshold</cite> eliminates noise in the second derivative
of the histogram. As the value is increased, you can expect a smoother
second derivative.  The default is 1.5:</p>
<pre class="literal-block">void            segment ( const double clusterThreshold_ = 1.0,
                          const double smoothingThreshold_ = 1.5 )</pre>
</section>
<section id="shade">
<h2><a class="toc-backref" href="#toc-entry-85" role="doc-backlink">shade</a></h2>
<p>Shade image using distant light source. Specify <cite>azimuth</cite> and
<cite>elevation</cite> as the position of the light source. By default, the
shading results as a grayscale image.. Set <cite>colorShading</cite> to true to
shade the red, green, and blue components of the image:</p>
<pre class="literal-block">void            shade ( const double azimuth_ = 30,
                        const double elevation_ = 30,
                        const bool   colorShading_ = false )</pre>
</section>
<section id="sharpen">
<h2><a class="toc-backref" href="#toc-entry-86" role="doc-backlink">sharpen</a></h2>
<p>Sharpen pixels in image.  The <cite>radius</cite> parameter specifies the radius
of the Gaussian, in pixels, not counting the center pixel.  The
<cite>sigma</cite> parameter specifies the standard deviation of the Laplacian,
in pixels:</p>
<pre class="literal-block">void            sharpen ( const double radius_ = 0.0,
                          const double sigma_ = 1.0 )</pre>
</section>
<section id="sharpenchannel">
<h2><a class="toc-backref" href="#toc-entry-87" role="doc-backlink">sharpenChannel</a></h2>
<p>Sharpen pixels in image channel.  The <cite>radius</cite> parameter specifies the
radius of the Gaussian, in pixels, not counting the center pixel.  The
<cite>sigma</cite> parameter specifies the standard deviation of the Laplacian,
in pixels:</p>
<pre class="literal-block">void            sharpenChannel ( const ChannelType channel_,
                                 const double radius_ = 0.0,
                                 const double sigma_ = 1.0 )</pre>
</section>
<section id="shave">
<h2><a class="toc-backref" href="#toc-entry-88" role="doc-backlink">shave</a></h2>
<p>Shave pixels from image edges:</p>
<pre class="literal-block">void            shave ( const Geometry &amp;geometry_ )</pre>
</section>
<section id="shear">
<h2><a class="toc-backref" href="#toc-entry-89" role="doc-backlink">shear</a></h2>
<p>Shear image (create parallelogram by sliding image by X or Y
axis). Shearing slides one edge of an image along the X or Y axis,
creating a parallelogram.  An X direction shear slides an edge along
the X axis, while a Y direction shear slides an edge along the Y axis.
The amount of the shear is controlled by a shear angle.  For X
direction shears, x degrees is measured relative to the Y axis, and
similarly, for Y direction shears y degrees is measured relative to
the X axis. Empty triangles left over from shearing the image are
filled with the <a class="reference external" href="Color.html">color</a> defined as borderColor:</p>
<pre class="literal-block">void            shear ( const double xShearAngle_,
                        const double yShearAngle_ )</pre>
</section>
<section id="solarize">
<h2><a class="toc-backref" href="#toc-entry-90" role="doc-backlink">solarize</a></h2>
<p>Solarize image (similar to effect seen when exposing a photographic
film to light during the development process):</p>
<pre class="literal-block">void            solarize ( const double factor_ = 50.0 )</pre>
</section>
<section id="spread">
<h2><a class="toc-backref" href="#toc-entry-91" role="doc-backlink">spread</a></h2>
<p>Spread pixels randomly within image by specified ammount:</p>
<pre class="literal-block">void            spread ( const unsigned int amount_ = 3 )</pre>
</section>
<section id="stegano">
<h2><a class="toc-backref" href="#toc-entry-92" role="doc-backlink">stegano</a></h2>
<p>Add a digital watermark to the image (based on second image):</p>
<pre class="literal-block">void            stegano ( const Image &amp;watermark_ )</pre>
</section>
<section id="stereo">
<h2><a class="toc-backref" href="#toc-entry-93" role="doc-backlink">stereo</a></h2>
<p>Create an image which appears in stereo when viewed with red-blue
glasses (Red image on left, blue on right):</p>
<pre class="literal-block">void            stereo ( const Image &amp;rightImage_ )</pre>
</section>
<section id="strip">
<h2><a class="toc-backref" href="#toc-entry-94" role="doc-backlink">strip</a></h2>
<p>Remove all profiles and text attributes from the image.</p>
<blockquote>
<p>void            strip ( void );</p>
</blockquote>
</section>
<section id="swirl">
<h2><a class="toc-backref" href="#toc-entry-95" role="doc-backlink">swirl</a></h2>
<p>Swirl image (image pixels are rotated by degrees):</p>
<pre class="literal-block">void            swirl ( const double degrees_ )</pre>
</section>
<section id="texture">
<h2><a class="toc-backref" href="#toc-entry-96" role="doc-backlink">texture</a></h2>
<p>Channel a texture on pixels matching image background <a class="reference external" href="Color.html">color</a>:</p>
<pre class="literal-block">void            texture ( const Image &amp;texture_ )</pre>
</section>
<section id="threshold">
<h2><a class="toc-backref" href="#toc-entry-97" role="doc-backlink">threshold</a></h2>
<p>Threshold image channels (below threshold becomes black, above
threshold becomes white).  The range of the threshold parameter is 0
to MaxRGB:</p>
<pre class="literal-block">void            threshold ( const double threshold_ )</pre>
</section>
<section id="transform">
<h2><a class="toc-backref" href="#toc-entry-98" role="doc-backlink">transform</a></h2>
<p>Transform image based on image and crop geometries. Crop geometry is
optional:</p>
<pre class="literal-block">void            transform ( const Geometry &amp;imageGeometry_ )

void            transform ( const Geometry &amp;imageGeometry_,
                            const Geometry &amp;cropGeometry_  )</pre>
</section>
<section id="transparent">
<h2><a class="toc-backref" href="#toc-entry-99" role="doc-backlink">transparent</a></h2>
<p>Add matte channel to image, setting pixels matching <a class="reference external" href="Color.html">color</a> to
transparent:</p>
<pre class="literal-block">void            transparent ( const Color &amp;color_ )</pre>
</section>
<section id="trim">
<h2><a class="toc-backref" href="#toc-entry-100" role="doc-backlink">trim</a></h2>
<p>Trim edges that are the background <a class="reference external" href="Color.html">color</a> from the image:</p>
<pre class="literal-block">void            trim ( void )</pre>
</section>
<section id="type">
<h2><a class="toc-backref" href="#toc-entry-101" role="doc-backlink">type</a></h2>
<p>Convert the image representation to the specified type or retrieve the
current image type.  If the image is reduced to an inferior type, then
image information may be lost (e.g. color changed to grayscale).</p>
<p>Available enumerations for the <cite>type</cite> parameter:</p>
<blockquote>
<dl class="simple">
<dt>BilevelType</dt>
<dd><p>black/white</p>
</dd>
<dt>GrayscaleType</dt>
<dd><p>grayscale</p>
</dd>
<dt>GrayscaleMatteType</dt>
<dd><p>grayscale with alpha (opacity) channel</p>
</dd>
<dt>PaletteType</dt>
<dd><p>colormapped</p>
</dd>
<dt>PaletteMatteType</dt>
<dd><p>colormapped with transparency</p>
</dd>
<dt>TrueColorType</dt>
<dd><p>true (full) color</p>
</dd>
<dt>TrueColorMatteType</dt>
<dd><p>true (full) color with alpha (opacity) channel</p>
</dd>
<dt>ColorSeparationType</dt>
<dd><p>Cyan, magenta, yellow, and black</p>
</dd>
<dt>ColorSeparationMatteType</dt>
<dd><p>Cyan, magenta, yellow, and black with alpha (opacity) channel</p>
</dd>
<dt>OptimizeType</dt>
<dd><p>Optimize the image type to best represent the existing pixels</p>
</dd>
</dl>
</blockquote>
<pre class="literal-block">void            type ( const ImageType type_ )

ImageType       type ( void ) const</pre>
</section>
<section id="unsharpmask">
<h2><a class="toc-backref" href="#toc-entry-102" role="doc-backlink">unsharpmask</a></h2>
<p>Replace image with a sharpened version of the original image using the
unsharp mask algorithm.</p>
<blockquote>
<dl class="simple">
<dt><cite>radius</cite></dt>
<dd><p>the radius of the Gaussian, in pixels, not counting the
center pixel.</p>
</dd>
<dt><cite>sigma</cite></dt>
<dd><p>the standard deviation of the Gaussian, in pixels.</p>
</dd>
<dt><cite>amount</cite></dt>
<dd><p>the percentage of the difference between the original and
the blur image that is added back into the original.</p>
</dd>
<dt><cite>threshold</cite></dt>
<dd><p>the threshold in pixels needed to apply the diffence amount.</p>
</dd>
</dl>
</blockquote>
<pre class="literal-block">void            unsharpmask ( const double radius_,
                              const double sigma_,
                              const double amount_,
                              const double threshold_ )</pre>
</section>
<section id="unsharpmaskchannel">
<h2><a class="toc-backref" href="#toc-entry-103" role="doc-backlink">unsharpmaskChannel</a></h2>
<p>Replace image channel with a sharpened version of the original image
using the unsharp mask algorithm.</p>
<blockquote>
<dl class="simple">
<dt><cite>channel</cite></dt>
<dd><p>image channel to modify.</p>
</dd>
<dt><cite>radius</cite></dt>
<dd><p>the radius of the Gaussian, in pixels, not counting the
center pixel.</p>
</dd>
<dt><cite>sigma</cite></dt>
<dd><p>the standard deviation of the Gaussian, in pixels.</p>
</dd>
<dt><cite>amount</cite></dt>
<dd><p>the percentage of the difference between the original and
the blur image that is added back into the original.</p>
</dd>
<dt><cite>threshold</cite></dt>
<dd><p>the threshold in pixels needed to apply the diffence amount.</p>
</dd>
</dl>
</blockquote>
<pre class="literal-block">void            unsharpmaskChannel ( const ChannelType channel_,
                                     const double radius_,
                                     const double sigma_,
                                     const double amount_,
                                     const double threshold_ );</pre>
</section>
<section id="wave">
<h2><a class="toc-backref" href="#toc-entry-104" role="doc-backlink">wave</a></h2>
<p>Map image pixels to a sine wave:</p>
<pre class="literal-block">void            wave ( const double amplitude_ = 25.0,
                       const double wavelength_ = 150.0 )</pre>
</section>
<section id="zoom">
<h2><a class="toc-backref" href="#toc-entry-105" role="doc-backlink">zoom</a></h2>
<p>Zoom (resize) image to specified size:</p>
<pre class="literal-block">void            zoom ( const Geometry &amp;geometry_ )</pre>
</section>
</section>
<section id="set-get-image-attributes">
<h1><a class="toc-backref" href="#toc-entry-6" role="doc-backlink">Set/Get Image Attributes</a></h1>
<p>Image attributes are set and obtained via methods in Image. Except for
methods which accept pointer arguments (e.g. chromaBluePrimary) all
methods return attributes by value.</p>
<p>Image attributes are easily used. For example, to set the resolution
of the TIFF file &quot;file.tiff&quot; to 150 dots-per-inch (DPI) in both the
horizontal and vertical directions, you can use the following example
code:</p>
<pre class="literal-block">string filename(&quot;file.tiff&quot;);
Image image;
image.read(filename);
image.resolutionUnits(PixelsPerInchResolution);
image.density(Geometry(150,150));   // could also use image.density(&quot;150x150&quot;)
image.write(filename)</pre>
<p>The following image attribute methods are available:</p>
<nav class="contents local" id="topic-3">
<ul class="simple">
<li><p><a class="reference internal" href="#adjoin" id="toc-entry-106">adjoin</a></p></li>
<li><p><a class="reference internal" href="#antialias" id="toc-entry-107">antiAlias</a></p></li>
<li><p><a class="reference internal" href="#animationdelay" id="toc-entry-108">animationDelay</a></p></li>
<li><p><a class="reference internal" href="#animationiterations" id="toc-entry-109">animationIterations</a></p></li>
<li><p><a class="reference internal" href="#attribute" id="toc-entry-110">attribute</a></p></li>
<li><p><a class="reference internal" href="#backgroundcolor" id="toc-entry-111">backgroundColor</a></p></li>
<li><p><a class="reference internal" href="#backgroundtexture" id="toc-entry-112">backgroundTexture</a></p></li>
<li><p><a class="reference internal" href="#basecolumns" id="toc-entry-113">baseColumns</a></p></li>
<li><p><a class="reference internal" href="#basefilename" id="toc-entry-114">baseFilename</a></p></li>
<li><p><a class="reference internal" href="#baserows" id="toc-entry-115">baseRows</a></p></li>
<li><p><a class="reference internal" href="#bordercolor" id="toc-entry-116">borderColor</a></p></li>
<li><p><a class="reference internal" href="#boundingbox" id="toc-entry-117">boundingBox</a></p></li>
<li><p><a class="reference internal" href="#boxcolor" id="toc-entry-118">boxColor</a></p></li>
<li><p><a class="reference internal" href="#cachethreshold" id="toc-entry-119">cacheThreshold</a></p></li>
<li><p><a class="reference internal" href="#chromablueprimary" id="toc-entry-120">chromaBluePrimary</a></p></li>
<li><p><a class="reference internal" href="#chromagreenprimary" id="toc-entry-121">chromaGreenPrimary</a></p></li>
<li><p><a class="reference internal" href="#chromaredprimary" id="toc-entry-122">chromaRedPrimary</a></p></li>
<li><p><a class="reference internal" href="#chromawhitepoint" id="toc-entry-123">chromaWhitePoint</a></p></li>
<li><p><a class="reference internal" href="#classtype" id="toc-entry-124">classType</a></p></li>
<li><p><a class="reference internal" href="#clipmask" id="toc-entry-125">clipMask</a></p></li>
<li><p><a class="reference internal" href="#colorfuzz" id="toc-entry-126">colorFuzz</a></p></li>
<li><p><a class="reference internal" href="#colormap" id="toc-entry-127">colorMap</a></p></li>
<li><p><a class="reference internal" href="#colormapsize" id="toc-entry-128">colorMapSize</a></p></li>
<li><p><a class="reference internal" href="#colorspace" id="toc-entry-129">colorSpace</a></p></li>
<li><p><a class="reference internal" href="#columns" id="toc-entry-130">columns</a></p></li>
<li><p><a class="reference internal" href="#comment-1" id="toc-entry-131">comment</a></p></li>
<li><p><a class="reference internal" href="#compose" id="toc-entry-132">compose</a></p></li>
<li><p><a class="reference internal" href="#compresstype" id="toc-entry-133">compressType</a></p></li>
<li><p><a class="reference internal" href="#debug" id="toc-entry-134">debug</a></p></li>
<li><p><a class="reference internal" href="#definevalue" id="toc-entry-135">defineValue</a></p></li>
<li><p><a class="reference internal" href="#defineset" id="toc-entry-136">defineSet</a></p></li>
<li><p><a class="reference internal" href="#density" id="toc-entry-137">density</a></p></li>
<li><p><a class="reference internal" href="#depth" id="toc-entry-138">depth</a></p></li>
<li><p><a class="reference internal" href="#directory" id="toc-entry-139">directory</a></p></li>
<li><p><a class="reference internal" href="#endian" id="toc-entry-140">endian</a></p></li>
<li><p><a class="reference internal" href="#filename" id="toc-entry-141">fileName</a></p></li>
<li><p><a class="reference internal" href="#filesize" id="toc-entry-142">fileSize</a></p></li>
<li><p><a class="reference internal" href="#fillcolor" id="toc-entry-143">fillColor</a></p></li>
<li><p><a class="reference internal" href="#fillpattern" id="toc-entry-144">fillPattern</a></p></li>
<li><p><a class="reference internal" href="#fillrule" id="toc-entry-145">fillRule</a></p></li>
<li><p><a class="reference internal" href="#filtertype" id="toc-entry-146">filterType</a></p></li>
<li><p><a class="reference internal" href="#font" id="toc-entry-147">font</a></p></li>
<li><p><a class="reference internal" href="#fontpointsize" id="toc-entry-148">fontPointsize</a></p></li>
<li><p><a class="reference internal" href="#fonttypemetrics" id="toc-entry-149">fontTypeMetrics</a></p></li>
<li><p><a class="reference internal" href="#format" id="toc-entry-150">format</a></p></li>
<li><p><a class="reference internal" href="#formatexpression" id="toc-entry-151">formatExpression</a></p></li>
<li><p><a class="reference internal" href="#formatexpressionref" id="toc-entry-152">formatExpressionRef</a></p></li>
<li><p><a class="reference internal" href="#gamma-1" id="toc-entry-153">gamma</a></p></li>
<li><p><a class="reference internal" href="#geometry-1" id="toc-entry-154">geometry</a></p></li>
<li><p><a class="reference internal" href="#gifdisposemethod" id="toc-entry-155">gifDisposeMethod</a></p></li>
<li><p><a class="reference internal" href="#icccolorprofile" id="toc-entry-156">iccColorProfile</a></p></li>
<li><p><a class="reference internal" href="#interlacetype" id="toc-entry-157">interlaceType</a></p></li>
<li><p><a class="reference internal" href="#iptcprofile" id="toc-entry-158">iptcProfile</a></p></li>
<li><p><a class="reference internal" href="#isvalid" id="toc-entry-159">isValid</a></p></li>
<li><p><a class="reference internal" href="#label-1" id="toc-entry-160">label</a></p></li>
<li><p><a class="reference internal" href="#linewidth" id="toc-entry-161">lineWidth</a></p></li>
<li><p><a class="reference internal" href="#magick" id="toc-entry-162">magick</a></p></li>
<li><p><a class="reference internal" href="#matte" id="toc-entry-163">matte</a></p></li>
<li><p><a class="reference internal" href="#mattecolor" id="toc-entry-164">matteColor</a></p></li>
<li><p><a class="reference internal" href="#meanerrorperpixel" id="toc-entry-165">meanErrorPerPixel</a></p></li>
<li><p><a class="reference internal" href="#modulusdepth" id="toc-entry-166">modulusDepth</a></p></li>
<li><p><a class="reference internal" href="#monochrome" id="toc-entry-167">monochrome</a></p></li>
<li><p><a class="reference internal" href="#montagegeometry" id="toc-entry-168">montageGeometry</a></p></li>
<li><p><a class="reference internal" href="#normalizedmaxerror" id="toc-entry-169">normalizedMaxError</a></p></li>
<li><p><a class="reference internal" href="#normalizedmeanerror" id="toc-entry-170">normalizedMeanError</a></p></li>
<li><p><a class="reference internal" href="#orientation" id="toc-entry-171">orientation</a></p></li>
<li><p><a class="reference internal" href="#page" id="toc-entry-172">page</a></p></li>
<li><p><a class="reference internal" href="#pixelcolor" id="toc-entry-173">pixelColor</a></p></li>
<li><p><a class="reference internal" href="#profile" id="toc-entry-174">profile</a></p></li>
<li><p><a class="reference internal" href="#quality" id="toc-entry-175">quality</a></p></li>
<li><p><a class="reference internal" href="#quantizecolors" id="toc-entry-176">quantizeColors</a></p></li>
<li><p><a class="reference internal" href="#quantizecolorspace" id="toc-entry-177">quantizeColorSpace</a></p></li>
<li><p><a class="reference internal" href="#quantizedither" id="toc-entry-178">quantizeDither</a></p></li>
<li><p><a class="reference internal" href="#quantizetreedepth" id="toc-entry-179">quantizeTreeDepth</a></p></li>
<li><p><a class="reference internal" href="#quiet" id="toc-entry-180">quiet</a></p></li>
<li><p><a class="reference internal" href="#renderingintent" id="toc-entry-181">renderingIntent</a></p></li>
<li><p><a class="reference internal" href="#repage" id="toc-entry-182">repage</a></p></li>
<li><p><a class="reference internal" href="#resolutionunits" id="toc-entry-183">resolutionUnits</a></p></li>
<li><p><a class="reference internal" href="#rows" id="toc-entry-184">rows</a></p></li>
<li><p><a class="reference internal" href="#scene" id="toc-entry-185">scene</a></p></li>
<li><p><a class="reference internal" href="#signature" id="toc-entry-186">signature</a></p></li>
<li><p><a class="reference internal" href="#size" id="toc-entry-187">size</a></p></li>
<li><p><a class="reference internal" href="#statistics" id="toc-entry-188">statistics</a></p></li>
<li><p><a class="reference internal" href="#strokeantialias" id="toc-entry-189">strokeAntiAlias</a></p></li>
<li><p><a class="reference internal" href="#strokecolor" id="toc-entry-190">strokeColor</a></p></li>
<li><p><a class="reference internal" href="#strokedasharray" id="toc-entry-191">strokeDashArray</a></p></li>
<li><p><a class="reference internal" href="#strokedashoffset" id="toc-entry-192">strokeDashOffset</a></p></li>
<li><p><a class="reference internal" href="#strokelinecap" id="toc-entry-193">strokeLineCap</a></p></li>
<li><p><a class="reference internal" href="#strokelinejoin" id="toc-entry-194">strokeLineJoin</a></p></li>
<li><p><a class="reference internal" href="#strokemiterlimit" id="toc-entry-195">strokeMiterLimit</a></p></li>
<li><p><a class="reference internal" href="#strokepattern" id="toc-entry-196">strokePattern</a></p></li>
<li><p><a class="reference internal" href="#strokewidth" id="toc-entry-197">strokeWidth</a></p></li>
<li><p><a class="reference internal" href="#subimage" id="toc-entry-198">subImage</a></p></li>
<li><p><a class="reference internal" href="#subrange" id="toc-entry-199">subRange</a></p></li>
<li><p><a class="reference internal" href="#textencoding" id="toc-entry-200">textEncoding</a></p></li>
<li><p><a class="reference internal" href="#tilename" id="toc-entry-201">tileName</a></p></li>
<li><p><a class="reference internal" href="#totalcolors" id="toc-entry-202">totalColors</a></p></li>
<li><p><a class="reference internal" href="#transformorigin" id="toc-entry-203">transformOrigin</a></p></li>
<li><p><a class="reference internal" href="#transformrotation" id="toc-entry-204">transformRotation</a></p></li>
<li><p><a class="reference internal" href="#transformreset" id="toc-entry-205">transformReset</a></p></li>
<li><p><a class="reference internal" href="#transformscale" id="toc-entry-206">transformScale</a></p></li>
<li><p><a class="reference internal" href="#transformskewx" id="toc-entry-207">transformSkewX</a></p></li>
<li><p><a class="reference internal" href="#transformskewy" id="toc-entry-208">transformSkewY</a></p></li>
<li><p><a class="reference internal" href="#verbose" id="toc-entry-209">verbose</a></p></li>
<li><p><a class="reference internal" href="#view" id="toc-entry-210">view</a></p></li>
<li><p><a class="reference internal" href="#x11display" id="toc-entry-211">x11Display</a></p></li>
<li><p><a class="reference internal" href="#xresolution" id="toc-entry-212">xResolution</a></p></li>
<li><p><a class="reference internal" href="#yresolution" id="toc-entry-213">yResolution</a></p></li>
</ul>
</nav>
<section id="adjoin">
<h2><a class="toc-backref" href="#toc-entry-106" role="doc-backlink">adjoin</a></h2>
<p>Join images into a single multi-image file:</p>
<pre class="literal-block">void            adjoin ( const bool flag_ )

bool            adjoin ( void ) const</pre>
</section>
<section id="antialias">
<h2><a class="toc-backref" href="#toc-entry-107" role="doc-backlink">antiAlias</a></h2>
<p>Control antialiasing of rendered Postscript and Postscript or TrueType
fonts. Enabled by default:</p>
<pre class="literal-block">void            antiAlias( const bool flag_ )

bool            antiAlias( void )</pre>
</section>
<section id="animationdelay">
<h2><a class="toc-backref" href="#toc-entry-108" role="doc-backlink">animationDelay</a></h2>
<p>Time in 1/100ths of a second (0 to 65535) which must expire before
displaying the next image in an animated sequence. This option is
useful for regulating the animation of a sequence of GIF images within
Netscape:</p>
<pre class="literal-block">void            animationDelay ( const unsigned int delay_ )

unsigned int    animationDelay ( void ) const</pre>
</section>
<section id="animationiterations">
<h2><a class="toc-backref" href="#toc-entry-109" role="doc-backlink">animationIterations</a></h2>
<p>Number of iterations to loop an animation (e.g. Netscape loop
extension) for:</p>
<pre class="literal-block">void            animationIterations ( const unsigned int iterations_ )

unsigned int    animationIterations ( void ) const</pre>
</section>
<section id="attribute">
<h2><a class="toc-backref" href="#toc-entry-110" role="doc-backlink">attribute</a></h2>
<p>Access or update an arbitrary named image attribute. Any number of
named attributes may be attached to the image. For example, the image
comment is a named image attribute with the name &quot;comment&quot;.  If the
named attribute already exists, the provided text is appended to the
existing attribute text.  Pass NULL to remove an existing text
attribute, or to restart the text attribute from scratch.</p>
<p>EXIF tags are attached to the image as named attributes. Use the
syntax &quot;EXIF:&lt;tag&gt;&quot; to request an EXIF tag similar to
&quot;EXIF:DateTime&quot;:</p>
<pre class="literal-block">void            attribute ( const std::string name_,
                            const char * value_ );

void            attribute ( const std::string name_,
                            const std::string value_ )

std::string     attribute ( const std::string name_ )</pre>
</section>
<section id="backgroundcolor">
<h2><a class="toc-backref" href="#toc-entry-111" role="doc-backlink">backgroundColor</a></h2>
<p>Image background <a class="reference external" href="Color.html">color</a>:</p>
<pre class="literal-block">void            backgroundColor ( const Color &amp;color_ )

Color           backgroundColor ( void ) const</pre>
</section>
<section id="backgroundtexture">
<h2><a class="toc-backref" href="#toc-entry-112" role="doc-backlink">backgroundTexture</a></h2>
<p>Image file name to use as the background texture. Does not modify
image pixels:</p>
<pre class="literal-block">void            backgroundTexture (const std::string &amp;backgroundTexture_ )

std::string     backgroundTexture ( void ) const</pre>
</section>
<section id="basecolumns">
<h2><a class="toc-backref" href="#toc-entry-113" role="doc-backlink">baseColumns</a></h2>
<p>Base image width (before transformations):</p>
<pre class="literal-block">unsigned int    baseColumns ( void ) const</pre>
</section>
<section id="basefilename">
<h2><a class="toc-backref" href="#toc-entry-114" role="doc-backlink">baseFilename</a></h2>
<p>Base image filename (before transformations):</p>
<pre class="literal-block">std::string     baseFilename ( void ) const</pre>
</section>
<section id="baserows">
<h2><a class="toc-backref" href="#toc-entry-115" role="doc-backlink">baseRows</a></h2>
<p>Base image height (before transformations):</p>
<pre class="literal-block">unsigned int    baseRows ( void ) const</pre>
</section>
<section id="bordercolor">
<h2><a class="toc-backref" href="#toc-entry-116" role="doc-backlink">borderColor</a></h2>
<p>Image border <a class="reference external" href="Color.html">color</a>:</p>
<pre class="literal-block">void            borderColor ( const Color &amp;color_ )

Color           borderColor ( void ) const</pre>
</section>
<section id="boundingbox">
<h2><a class="toc-backref" href="#toc-entry-117" role="doc-backlink">boundingBox</a></h2>
<p>Return smallest bounding box enclosing non-border pixels. The
current fuzz value is used when discriminating between pixels.
This is the crop bounding box used by <span class="docutils literal">crop(Geometry(0,0))</span>:</p>
<pre class="literal-block">Geometry        boundingBox ( void ) const</pre>
</section>
<section id="boxcolor">
<h2><a class="toc-backref" href="#toc-entry-118" role="doc-backlink">boxColor</a></h2>
<p>Base <a class="reference external" href="Color.html">color</a> that annotation text is rendered on (default none):</p>
<pre class="literal-block">void            boxColor ( const Color &amp;boxColor_ )

Color           boxColor ( void ) const</pre>
</section>
<section id="cachethreshold">
<h2><a class="toc-backref" href="#toc-entry-119" role="doc-backlink">cacheThreshold</a></h2>
<p>Pixel cache threshold in megabytes.  Once this memory threshold is
exceeded, all subsequent pixels cache operations are to/from disk.
This setting is shared by all Image objects:</p>
<pre class="literal-block">static void     cacheThreshold ( const unsigned int threshold_ )</pre>
</section>
<section id="chromablueprimary">
<h2><a class="toc-backref" href="#toc-entry-120" role="doc-backlink">chromaBluePrimary</a></h2>
<p>Chromaticity blue primary point (e.g. x=0.15, y=0.06):</p>
<pre class="literal-block">void            chromaBluePrimary ( const double x_, const double y_ )

void            chromaBluePrimary ( double *x_, double *y_ ) const</pre>
</section>
<section id="chromagreenprimary">
<h2><a class="toc-backref" href="#toc-entry-121" role="doc-backlink">chromaGreenPrimary</a></h2>
<p>Chromaticity green primary point (e.g. x=0.3, y=0.6):</p>
<pre class="literal-block">void            chromaGreenPrimary ( const double x_, const double y_ )

void            chromaGreenPrimary ( double *x_, double *y_ ) const</pre>
</section>
<section id="chromaredprimary">
<h2><a class="toc-backref" href="#toc-entry-122" role="doc-backlink">chromaRedPrimary</a></h2>
<p>Chromaticity red primary point (e.g. x=0.64, y=0.33):</p>
<pre class="literal-block">void            chromaRedPrimary ( const double x_, const double y_ )

void            chromaRedPrimary ( double *x_, double *y_ ) const</pre>
</section>
<section id="chromawhitepoint">
<h2><a class="toc-backref" href="#toc-entry-123" role="doc-backlink">chromaWhitePoint</a></h2>
<p>Chromaticity white point (e.g. x=0.3127, y=0.329):</p>
<pre class="literal-block">void            chromaWhitePoint ( const double x_, const double y_ )
void            chromaWhitePoint ( double *x_, double *y_ ) const</pre>
</section>
<section id="classtype">
<h2><a class="toc-backref" href="#toc-entry-124" role="doc-backlink">classType</a></h2>
<p>Image class (DirectClass or PseudoClass).  NOTE: setting a DirectClass
image to PseudoClass will result in the loss of color information if
the number of colors in the image is greater than the maximum palette
size (either 256 or 65536 entries depending on the value of
QuantumDepth when ImageMagick was built):</p>
<pre class="literal-block">void            classType ( const ClassType class_ )

ClassType       classType ( void ) const</pre>
</section>
<section id="clipmask">
<h2><a class="toc-backref" href="#toc-entry-125" role="doc-backlink">clipMask</a></h2>
<p>Associate a clip mask image with the current image. The clip mask
image must have the same dimensions as the current image or an
exception is thrown. Clipping occurs wherever pixels are transparent
in the clip mask image. Clipping Pass an invalid image to unset an
existing clip mask:</p>
<pre class="literal-block">void            clipMask ( const Image &amp; clipMask_ )

Image           clipMask ( void  ) const</pre>
</section>
<section id="colorfuzz">
<h2><a class="toc-backref" href="#toc-entry-126" role="doc-backlink">colorFuzz</a></h2>
<p>Colors within this distance are considered equal. A number of
algorithms search for a target color. By default the color must be
exact. Use this option to match colors that are close to the target
color in RGB space:</p>
<pre class="literal-block">void            colorFuzz ( const double fuzz_ )

double          colorFuzz ( void ) const</pre>
</section>
<section id="colormap">
<h2><a class="toc-backref" href="#toc-entry-127" role="doc-backlink">colorMap</a></h2>
<p><a class="reference external" href="Color.html">Color</a> at colormap position <cite>index</cite>:</p>
<pre class="literal-block">void            colorMap ( const unsigned int index_,
                           const Color &amp;color_ )

Color           colorMap ( const unsigned int index_ ) const</pre>
</section>
<section id="colormapsize">
<h2><a class="toc-backref" href="#toc-entry-128" role="doc-backlink">colorMapSize</a></h2>
<p>Number of entries in the colormap. Setting the colormap size may
extend or truncate the colormap. The maximum number of supported
entries is specified by the MaxColormapSize constant, and is dependent
on the value of QuantumDepth when GraphicsMagick is compiled. An
exception is thrown if more entries are requested than may be
supported. Care should be taken when truncating the colormap to ensure
that the image colormap indexes reference valid colormap entries:</p>
<pre class="literal-block">void            colorMapSize ( const unsigned int entries_ )

unsigned int    colorMapSize ( void )</pre>
</section>
<section id="colorspace">
<h2><a class="toc-backref" href="#toc-entry-129" role="doc-backlink">colorSpace</a></h2>
<p>The colorspace (e.g. CMYK) used to represent the image pixel colors:</p>
<pre class="literal-block">void            colorSpace( const ColorspaceType colorSpace_ )

ColorspaceType  colorSpace ( void ) const</pre>
</section>
<section id="columns">
<h2><a class="toc-backref" href="#toc-entry-130" role="doc-backlink">columns</a></h2>
<p>Image width:</p>
<pre class="literal-block">unsigned int    columns ( void ) const</pre>
</section>
<section id="comment-1">
<h2><a class="toc-backref" href="#toc-entry-131" role="doc-backlink">comment</a></h2>
<p>Image comment:</p>
<pre class="literal-block">std::string     comment ( void ) const</pre>
</section>
<section id="compose">
<h2><a class="toc-backref" href="#toc-entry-132" role="doc-backlink">compose</a></h2>
<p>Composition operator to be used when composition is implicitly
used (such as for image flattening):</p>
<pre class="literal-block">void            compose (const CompositeOperator compose_)

CompositeOperator compose ( void ) const</pre>
</section>
<section id="compresstype">
<h2><a class="toc-backref" href="#toc-entry-133" role="doc-backlink">compressType</a></h2>
<p>Image compresion type. The default is the compression type of the
input image file:</p>
<pre class="literal-block">void            compressType ( const CompressionType compressType_ )

CompressionType compressType ( void ) const</pre>
</section>
<section id="debug">
<h2><a class="toc-backref" href="#toc-entry-134" role="doc-backlink">debug</a></h2>
<p>Enable printing of debug messages from GraphicsMagick as it executes:</p>
<pre class="literal-block">void            debug ( const bool flag_ )

bool            debug ( void ) const</pre>
</section>
<section id="definevalue">
<h2><a class="toc-backref" href="#toc-entry-135" role="doc-backlink">defineValue</a></h2>
<p>Set or obtain a definition string to applied when encoding or decoding
the specified format. The meanings of the definitions are format
specific. The format is designated by the <cite>magick</cite> argument, the
format-specific key is designated by <cite>key</cite>, and the associated value
is specified by <cite>value</cite>. See the defineSet() method if the key must be
removed entirely:</p>
<pre class="literal-block">void            defineValue ( const std::string &amp;magick_,
                              const std::string &amp;key_,
                              const std::string &amp;value_ )

std::string     defineValue ( const std::string &amp;magick_,
                              const std::string &amp;key_ ) const</pre>
</section>
<section id="defineset">
<h2><a class="toc-backref" href="#toc-entry-136" role="doc-backlink">defineSet</a></h2>
<p>Set or obtain a definition flag to applied when encoding or decoding
the specified format. Similar to the defineValue() method except that
passing the <cite>flag</cite> value 'true' creates a value-less define with that
format and key. Passing the <cite>flag</cite> value 'false' removes any existing
matching definition. The method returns 'true' if a matching key
exists, and 'false' if no matching key exists:</p>
<pre class="literal-block">void            defineSet ( const std::string &amp;magick_,
                            const std::string &amp;key_,
                            bool flag_ )

bool            defineSet ( const std::string &amp;magick_,
                            const std::string &amp;key_ ) const</pre>
</section>
<section id="density">
<h2><a class="toc-backref" href="#toc-entry-137" role="doc-backlink">density</a></h2>
<p>Vertical and horizontal resolution in pixels of the image. This option
specifies an image density when decoding a Postscript or Portable
Document page. Often used with <cite>psPageSize</cite>:</p>
<pre class="literal-block">void            density ( const Geometry &amp;geomery_ )

Geometry        density ( void ) const</pre>
<p>Please note that the 'density' method suffers from a design problem in
that the Geometry object only supports integer dimensions, but the
underlying image resolution is a floating point value.  This results
in rounding off the value.  Please see the xResolution() and
yResolution() methods for a way to set and get the resolution in
floating point.</p>
<p>The resolution units may be obtained via the resolutionUnits() method.</p>
</section>
<section id="depth">
<h2><a class="toc-backref" href="#toc-entry-138" role="doc-backlink">depth</a></h2>
<p>Image depth (bits allocated to red/green/blue components). Used to
specify the bit depth when reading or writing raw images or when the
output format supports multiple depths. Defaults to the quantum depth
that GraphicsMagick is compiled with:</p>
<pre class="literal-block">void            depth ( const unsigned int depth_ )

unsigned int    depth ( void ) const</pre>
</section>
<section id="directory">
<h2><a class="toc-backref" href="#toc-entry-139" role="doc-backlink">directory</a></h2>
<p>Tile names from within an image montage:</p>
<pre class="literal-block">std::string     directory ( void ) const</pre>
</section>
<section id="endian">
<h2><a class="toc-backref" href="#toc-entry-140" role="doc-backlink">endian</a></h2>
<p>Endianness (<cite>LSBEndian</cite> like Intel, <cite>MSBEndian</cite> like SPARC, or
<cite>NativeEndian</cite> for what this computer uses) for image formats which
support endian-specific options:</p>
<pre class="literal-block">void            endian ( const EndianType endian_ )

EndianType      endian ( void ) const</pre>
</section>
<section id="filename">
<h2><a class="toc-backref" href="#toc-entry-141" role="doc-backlink">fileName</a></h2>
<p>Image file name:</p>
<pre class="literal-block">void            fileName ( const std::string &amp;fileName_ )

std::string     fileName ( void ) const</pre>
</section>
<section id="filesize">
<h2><a class="toc-backref" href="#toc-entry-142" role="doc-backlink">fileSize</a></h2>
<p>Number of bytes of the image on disk:</p>
<pre class="literal-block">off_t          fileSize ( void ) const</pre>
</section>
<section id="fillcolor">
<h2><a class="toc-backref" href="#toc-entry-143" role="doc-backlink">fillColor</a></h2>
<p><a class="reference external" href="Color.html">Color</a> to use when filling drawn objects:</p>
<pre class="literal-block">void            fillColor ( const Color &amp;fillColor_ )

Color           fillColor ( void ) const</pre>
</section>
<section id="fillpattern">
<h2><a class="toc-backref" href="#toc-entry-144" role="doc-backlink">fillPattern</a></h2>
<p>Pattern to use while filling drawn objects:</p>
<pre class="literal-block">void            fillPattern ( const Image &amp;fillPattern_ )

Image           fillPattern ( void  ) const</pre>
</section>
<section id="fillrule">
<h2><a class="toc-backref" href="#toc-entry-145" role="doc-backlink">fillRule</a></h2>
<p>Rule to use when filling drawn objects:</p>
<pre class="literal-block">void            fillRule ( const FillRule &amp;fillRule_ )

FillRule        fillRule ( void ) const</pre>
</section>
<section id="filtertype">
<h2><a class="toc-backref" href="#toc-entry-146" role="doc-backlink">filterType</a></h2>
<p>Filter to use when resizing image. The reduction filter employed has a
sigificant effect on the time required to resize an image and the
resulting quality. The default filter is Lanczos which has been shown
to produce high quality results when reducing most images:</p>
<pre class="literal-block">void            filterType ( const FilterTypes filterType_ )

FilterTypes     filterType ( void ) const</pre>
</section>
<section id="font">
<h2><a class="toc-backref" href="#toc-entry-147" role="doc-backlink">font</a></h2>
<p>Text rendering font. If the font is a fully qualified X server font
name, the font is obtained from an X server. To use a TrueType font,
precede the TrueType filename with an &#64;. Otherwise, specify a
Postscript font name (e.g. &quot;helvetica&quot;).:</p>
<pre class="literal-block">void            font ( const std::string &amp;font_ )

std::string     font ( void ) const</pre>
</section>
<section id="fontpointsize">
<h2><a class="toc-backref" href="#toc-entry-148" role="doc-backlink">fontPointsize</a></h2>
<p>Text rendering font point size:</p>
<pre class="literal-block">void            fontPointsize ( const double pointSize_ )

double          fontPointsize ( void ) const</pre>
</section>
<section id="fonttypemetrics">
<h2><a class="toc-backref" href="#toc-entry-149" role="doc-backlink">fontTypeMetrics</a></h2>
<p>Obtain font metrics (see <a class="reference external" href="TypeMetric.html">TypeMetric</a>) for text string given current
font, pointsize, and density settings.  This information is necessary
in order to do fancy layout of text:</p>
<pre class="literal-block">void            fontTypeMetrics( const std::string &amp;text_,
                                 TypeMetric *metrics )</pre>
</section>
<section id="format">
<h2><a class="toc-backref" href="#toc-entry-150" role="doc-backlink">format</a></h2>
<p>Long image format description:</p>
<pre class="literal-block">std::string     format ( void ) const</pre>
</section>
<section id="formatexpression">
<h2><a class="toc-backref" href="#toc-entry-151" role="doc-backlink">formatExpression</a></h2>
<p>Format a string based on image properties similar to <cite>identify</cite>
<cite>-format</cite>.  For example, the format expression &quot;%wx%h&quot; is converted to
a string containing image WIDTHxHEIGHT like &quot;640x480&quot;:</p>
<pre class="literal-block">std::string     formatExpression( const std::string expression )</pre>
<p>Please note that this method is not a const method (may modify the
Image object and will assure a reference count of one) and it <em>may</em>
throw an exception if there is an internal error.</p>
<p>The formatExpressionRef() method is preferred given that the argument
is passed by reference, but formatExpression() is in all editions of
Magick++.</p>
</section>
<section id="formatexpressionref">
<h2><a class="toc-backref" href="#toc-entry-152" role="doc-backlink">formatExpressionRef</a></h2>
<p>Format a string based on image properties similar to <cite>identify</cite>
<cite>-format</cite>.  For example, the format expression &quot;%wx%h&quot; is converted to
a string containing image WIDTHxHEIGHT like &quot;640x480&quot;:</p>
<pre class="literal-block">std::string     formatExpression( const std::string &amp;expression )</pre>
<p>Please note that this method is not a const method (may modify the
Image object and will assure a reference count of one) and it <em>may</em>
throw an exception if there is an internal error.</p>
</section>
<section id="gamma-1">
<h2><a class="toc-backref" href="#toc-entry-153" role="doc-backlink">gamma</a></h2>
<p>Gamma level of the image.  Gamma is a pow() function which converts
between the linear light representation and the representation for the
computer display.  Most computer images are gamma corrected to 2.2
(1/0.4545) so that each step results in a visually linear step on a
computer or video display:</p>
<pre class="literal-block">double          gamma ( void ) const</pre>
</section>
<section id="geometry-1">
<h2><a class="toc-backref" href="#toc-entry-154" role="doc-backlink">geometry</a></h2>
<p>Preferred size of the image when encoding:</p>
<pre class="literal-block">Geometry        geometry ( void ) const</pre>
</section>
<section id="gifdisposemethod">
<h2><a class="toc-backref" href="#toc-entry-155" role="doc-backlink">gifDisposeMethod</a></h2>
<p>GIF disposal method. This option (specific to the GIF file format) is
used to control how successive frames are rendered (how the preceding
frame is disposed of) when creating a GIF animation:</p>
<pre class="literal-block">void            gifDisposeMethod ( const unsigned int disposeMethod_ )

unsigned int    gifDisposeMethod ( void ) const</pre>
</section>
<section id="icccolorprofile">
<h2><a class="toc-backref" href="#toc-entry-156" role="doc-backlink">iccColorProfile</a></h2>
<p>ICC color profile. Supplied via a <a class="reference external" href="Blob.html">Blob</a> since Magick++/ and
GraphicsMagick do not currently support formating this data structure
directly.</p>
<p>If there is not already an ICC color profile, the profile is merely
attached to the image without transforming the pixels.  If there is
already an ICC color profile (the source profile), the pixels are
translated according to the source and target profiles, and the
existing profile is replaced with the target profile.</p>
<p>Also see <a class="reference internal" href="#renderingintent">renderingIntent</a>, which allows specifying the rendering
intent if the profile is executed.</p>
<p>Specifications for ICC color profiles and their usage are available
from the International Color Consortium for the format of ICC color
profiles:</p>
<pre class="literal-block">void            iccColorProfile( const Blob &amp;colorProfile_ )

Blob            iccColorProfile( void ) const</pre>
</section>
<section id="interlacetype">
<h2><a class="toc-backref" href="#toc-entry-157" role="doc-backlink">interlaceType</a></h2>
<p>The type of interlacing scheme (default <cite>NoInterlace</cite> ). This option
is used to specify the type of interlacing scheme for raw image
formats such as RGB or YUV. <cite>NoInterlace</cite> means do not interlace,
<cite>LineInterlace</cite> uses scanline interlacing, and <cite>PlaneInterlace</cite> uses
plane interlacing. <cite>PartitionInterlace</cite> is like <cite>PlaneInterlace</cite>
except the different planes are saved to individual files (e.g.
image.R, image.G, and image.B). Use <cite>LineInterlace</cite> or
<cite>PlaneInterlace</cite> to create an interlaced GIF or progressive JPEG
image:</p>
<pre class="literal-block">void            interlaceType ( const InterlaceType interlace_ )

InterlaceType   interlaceType ( void ) const</pre>
</section>
<section id="iptcprofile">
<h2><a class="toc-backref" href="#toc-entry-158" role="doc-backlink">iptcProfile</a></h2>
<p>IPTC profile. Supplied via a <a class="reference external" href="Blob.html">Blob</a> since Magick++ and GraphicsMagick do
not currently support formating this data structure
directly. Specifications are available from the International Press
Telecommunications Council for IPTC profiles:</p>
<pre class="literal-block">void            iptcProfile( const Blob&amp; iptcProfile_ )

Blob            iptcProfile( void ) const</pre>
</section>
<section id="isvalid">
<h2><a class="toc-backref" href="#toc-entry-159" role="doc-backlink">isValid</a></h2>
<p>Does object contain valid image? Set to <cite>false</cite> in order to invalidate
the image. Images constructed via the default constructor are invalid
images and isValid() will return false:</p>
<pre class="literal-block">void            isValid ( const bool isValid_ )

bool            isValid ( void ) const</pre>
</section>
<section id="label-1">
<h2><a class="toc-backref" href="#toc-entry-160" role="doc-backlink">label</a></h2>
<p>Image label:</p>
<pre class="literal-block">std::string     label ( void ) const</pre>
</section>
<section id="linewidth">
<h2><a class="toc-backref" href="#toc-entry-161" role="doc-backlink">lineWidth</a></h2>
<p>Stroke width for drawing vector objects (default one)
This method is now deprecated. Please use strokeWidth instead:</p>
<pre class="literal-block">void            lineWidth ( const double lineWidth_ )

double          lineWidth ( void ) const</pre>
</section>
<section id="magick">
<h2><a class="toc-backref" href="#toc-entry-162" role="doc-backlink">magick</a></h2>
<p>File type magick identifier (.e.g &quot;GIF&quot;):</p>
<pre class="literal-block">void            magick ( const std::string &amp;magick_ )

std::string     magick ( void ) const</pre>
</section>
<section id="matte">
<h2><a class="toc-backref" href="#toc-entry-163" role="doc-backlink">matte</a></h2>
<p>Image supports transparency (matte channel):</p>
<pre class="literal-block">void            matte ( const bool matteFlag_ )

bool            matte ( void ) const</pre>
</section>
<section id="mattecolor">
<h2><a class="toc-backref" href="#toc-entry-164" role="doc-backlink">matteColor</a></h2>
<p>Image matte (frame) <a class="reference external" href="Color.html">color</a>:</p>
<pre class="literal-block">void            matteColor ( const Color &amp;matteColor_ )

Color           matteColor ( void ) const</pre>
</section>
<section id="meanerrorperpixel">
<h2><a class="toc-backref" href="#toc-entry-165" role="doc-backlink">meanErrorPerPixel</a></h2>
<p>The mean error per pixel computed when an image is color reduced. This
parameter is only valid if verbose is set to true and the image has
just been quantized:</p>
<pre class="literal-block">double          meanErrorPerPixel ( void ) const</pre>
</section>
<section id="modulusdepth">
<h2><a class="toc-backref" href="#toc-entry-166" role="doc-backlink">modulusDepth</a></h2>
<p>Image modulus depth (minimum number of bits required to support
red/green/blue components without loss of accuracy). The pixel modulus
depth may be decreased by supplying a value which is less than the
current value, updating the pixels (reducing accuracy) to the new
depth. The pixel modulus depth can not be increased over the current
value using this method:</p>
<pre class="literal-block">void            modulusDepth ( const unsigned int modulusDepth_ )

unsigned int    modulusDepth ( void ) const</pre>
</section>
<section id="monochrome">
<h2><a class="toc-backref" href="#toc-entry-167" role="doc-backlink">monochrome</a></h2>
<p>Transform image to black and white while color reducing (quantizing):</p>
<pre class="literal-block">void            monochrome ( const bool monochromeFlag_ )

bool            monochrome ( void ) const</pre>
</section>
<section id="montagegeometry">
<h2><a class="toc-backref" href="#toc-entry-168" role="doc-backlink">montageGeometry</a></h2>
<p>Tile size and offset within an image montage. Only valid for montage
images:</p>
<pre class="literal-block">Geometry        montageGeometry ( void ) const</pre>
</section>
<section id="normalizedmaxerror">
<h2><a class="toc-backref" href="#toc-entry-169" role="doc-backlink">normalizedMaxError</a></h2>
<p>The normalized max error per pixel computed when an image is color
reduced. This parameter is only valid if verbose is set to true and
the image has just been quantized:</p>
<pre class="literal-block">double          normalizedMaxError ( void ) const</pre>
</section>
<section id="normalizedmeanerror">
<h2><a class="toc-backref" href="#toc-entry-170" role="doc-backlink">normalizedMeanError</a></h2>
<p>The normalized mean error per pixel computed when an image is color
reduced. This parameter is only valid if verbose is set to true and
the image has just been quantized:</p>
<pre class="literal-block">double          normalizedMeanError ( void ) const</pre>
</section>
<section id="orientation">
<h2><a class="toc-backref" href="#toc-entry-171" role="doc-backlink">orientation</a></h2>
<p>Image orientation.  Supported by some file formats such as DPX and
TIFF. Useful for turning the right way up:</p>
<pre class="literal-block">void            orientation ( const OrientationType orientation_ )

OrientationType orientation ( void ) const</pre>
</section>
<section id="page">
<h2><a class="toc-backref" href="#toc-entry-172" role="doc-backlink">page</a></h2>
<p>Preferred size and location of an image canvas.</p>
<p>Use this option to specify the dimensions and position of the
Postscript page in dots per inch or a TEXT page in pixels. This option
is typically used in concert with density .</p>
<p>Page may also be used to position a GIF image (such as for a scene in
an animation):</p>
<pre class="literal-block">void            page ( const Geometry &amp;pageSize_ )

Geometry        page ( void ) const</pre>
</section>
<section id="pixelcolor">
<h2><a class="toc-backref" href="#toc-entry-173" role="doc-backlink">pixelColor</a></h2>
<p>Get/set pixel <a class="reference external" href="Color.html">color</a> at location x &amp; y:</p>
<pre class="literal-block">void            pixelColor ( const unsigned int x_,
                             const unsigned int y_,
                             const Color &amp;color_ )

Color           pixelColor ( const unsigned int x_,
                             const unsigned int y_ ) const</pre>
</section>
<section id="profile">
<h2><a class="toc-backref" href="#toc-entry-174" role="doc-backlink">profile</a></h2>
<p>Add or remove a named profile to/from the image. Remove the
profile by passing an empty <a class="reference external" href="Blob.html">Blob</a> (e.g. Blob()). Valid names are
&quot;*&quot;, &quot;8BIM&quot;, &quot;ICM&quot;, &quot;IPTC&quot;, or a user/format-defined profile name:</p>
<pre class="literal-block">void            profile( const std::string name_,
                         const Blob &amp;colorProfile_ )</pre>
<p>Retrieve a named profile from the image. Valid names are:
&quot;8BIM&quot;, &quot;8BIMTEXT&quot;, &quot;APP1&quot;, &quot;APP1JPEG&quot;, &quot;ICC&quot;, &quot;ICM&quot;, &amp; &quot;IPTC&quot;
or an existing user/format-defined profile name:</p>
<pre class="literal-block">Blob            profile( const std::string name_ ) const</pre>
</section>
<section id="quality">
<h2><a class="toc-backref" href="#toc-entry-175" role="doc-backlink">quality</a></h2>
<p>JPEG/MIFF/PNG compression level (default 75):</p>
<pre class="literal-block">void            quality ( const unsigned int quality_ )

unsigned int    quality ( void ) const</pre>
</section>
<section id="quantizecolors">
<h2><a class="toc-backref" href="#toc-entry-176" role="doc-backlink">quantizeColors</a></h2>
<p>Maximum number of colors to quantize to:</p>
<pre class="literal-block">void            quantizeColors ( const unsigned int colors_ )

unsigned int    quantizeColors ( void ) const</pre>
</section>
<section id="quantizecolorspace">
<h2><a class="toc-backref" href="#toc-entry-177" role="doc-backlink">quantizeColorSpace</a></h2>
<p>Colorspace to quantize in (default RGB). Empirical evidence suggests
that distances in color spaces such as YUV or YIQ correspond to
perceptual color differences more closely than do distances in RGB
space. These color spaces may give better results when color reducing
an image:</p>
<pre class="literal-block">void            quantizeColorSpace ( const ColorspaceType colorSpace_ )

ColorspaceType  quantizeColorSpace ( void ) const</pre>
</section>
<section id="quantizedither">
<h2><a class="toc-backref" href="#toc-entry-178" role="doc-backlink">quantizeDither</a></h2>
<p>Apply Floyd/Steinberg error diffusion to the image. The basic strategy
of dithering is to trade intensity resolution for spatial resolution
by averaging the intensities of several neighboring pixels. Images
which suffer from severe contouring when reducing colors can be
improved with this option. The quantizeColors or monochrome option
must be set for this option to take effect:</p>
<pre class="literal-block">void            quantizeDither ( const bool ditherFlag_ )

bool            quantizeDither ( void ) const</pre>
</section>
<section id="quantizetreedepth">
<h2><a class="toc-backref" href="#toc-entry-179" role="doc-backlink">quantizeTreeDepth</a></h2>
<p>Depth of the quantization color classification tree. Values of 0 or 1
allow selection of the optimal tree depth for the color reduction
algorithm. Values between 2 and 8 may be used to manually adjust the
tree depth:</p>
<pre class="literal-block">void            quantizeTreeDepth ( const unsigned int treeDepth_ )

unsigned int    quantizeTreeDepth ( void ) const</pre>
</section>
<section id="quiet">
<h2><a class="toc-backref" href="#toc-entry-180" role="doc-backlink">quiet</a></h2>
<p>Determines if Warning exceptions will be thrown, or suppressed.
The default is that warnings will be thrown (i.e. false):</p>
<pre class="literal-block">void            quiet ( const bool quiet_ );
bool            quiet ( void ) const;</pre>
</section>
<section id="renderingintent">
<h2><a class="toc-backref" href="#toc-entry-181" role="doc-backlink">renderingIntent</a></h2>
<p>The type of rendering intent (used when applying an ICC color
profile using <a class="reference internal" href="#icccolorprofile">iccColorProfile</a>):</p>
<pre class="literal-block">void            renderingIntent ( const RenderingIntent renderingIntent_ )

RenderingIntent renderingIntent ( void ) const</pre>
</section>
<section id="repage">
<h2><a class="toc-backref" href="#toc-entry-182" role="doc-backlink">repage</a></h2>
<p>Reset the image page canvas and position:</p>
<pre class="literal-block">void            repage();</pre>
</section>
<section id="resolutionunits">
<h2><a class="toc-backref" href="#toc-entry-183" role="doc-backlink">resolutionUnits</a></h2>
<p>Units of image resolution:</p>
<pre class="literal-block">void            resolutionUnits ( const ResolutionType resolutionUnits_ )

ResolutionType  resolutionUnits ( void ) const</pre>
</section>
<section id="rows">
<h2><a class="toc-backref" href="#toc-entry-184" role="doc-backlink">rows</a></h2>
<p>The number of pixel rows in the image:</p>
<pre class="literal-block">unsigned int    rows ( void ) const</pre>
</section>
<section id="scene">
<h2><a class="toc-backref" href="#toc-entry-185" role="doc-backlink">scene</a></h2>
<p>Image scene number:</p>
<pre class="literal-block">void            scene ( const unsigned int scene_ )

unsigned int    scene ( void ) const</pre>
</section>
<section id="signature">
<h2><a class="toc-backref" href="#toc-entry-186" role="doc-backlink">signature</a></h2>
<p>Image textual signature.  Set <cite>force</cite> to true in order to re-calculate
the signature regardless of whether the image data has been modified:</p>
<pre class="literal-block">std::string     signature ( const bool force_ = false ) const</pre>
</section>
<section id="size">
<h2><a class="toc-backref" href="#toc-entry-187" role="doc-backlink">size</a></h2>
<p>Width and height of a raw image (an image which does not support width
and height information).  Size may also be used to affect the image
size read from a multi-resolution format (e.g. Photo CD, JBIG, or
JPEG:</p>
<pre class="literal-block">void            size ( const Geometry &amp;geometry_ )

Geometry        size ( void ) const</pre>
</section>
<section id="statistics">
<h2><a class="toc-backref" href="#toc-entry-188" role="doc-backlink">statistics</a></h2>
<p>Obtain image statistics. Statistics are normalized to the range
of 0.0 to 1.0 and are output to the specified ImageStatistics
structure:</p>
<pre class="literal-block">void            statistics ( ImageStatistics *statistics ) const</pre>
</section>
<section id="strokeantialias">
<h2><a class="toc-backref" href="#toc-entry-189" role="doc-backlink">strokeAntiAlias</a></h2>
<p>Enable/disable stroke anti-aliasing:</p>
<pre class="literal-block">void            strokeAntiAlias( const bool flag_ )

bool            strokeAntiAlias( void ) const</pre>
</section>
<section id="strokecolor">
<h2><a class="toc-backref" href="#toc-entry-190" role="doc-backlink">strokeColor</a></h2>
<p><a class="reference external" href="Color.html">Color</a> to use when drawing object outlines:</p>
<pre class="literal-block">void            strokeColor ( const Color &amp;strokeColor_ )

Color           strokeColor ( void ) const</pre>
</section>
<section id="strokedasharray">
<h2><a class="toc-backref" href="#toc-entry-191" role="doc-backlink">strokeDashArray</a></h2>
<p>Specify the pattern of dashes and gaps used to stroke paths. The
strokeDashArray represents a zero-terminated array of numbers that
specify the lengths of alternating dashes and gaps in pixels. If an
odd number of values is provided, then the list of values is repeated
to yield an even number of values.  A typical <cite>strokeDashArray</cite> array
might contain the members 5 3 2 0, where the zero value indicates the
end of the pattern array:</p>
<pre class="literal-block">void            strokeDashArray ( const double* strokeDashArray_ )

const double*   strokeDashArray ( void ) const</pre>
</section>
<section id="strokedashoffset">
<h2><a class="toc-backref" href="#toc-entry-192" role="doc-backlink">strokeDashOffset</a></h2>
<p>While drawing using a dash pattern, specify distance into the
dash pattern to start the dash (default 0):</p>
<pre class="literal-block">void            strokeDashOffset ( const double strokeDashOffset_ )

double          strokeDashOffset ( void ) const</pre>
</section>
<section id="strokelinecap">
<h2><a class="toc-backref" href="#toc-entry-193" role="doc-backlink">strokeLineCap</a></h2>
<p>Specify the shape to be used at the end of open subpaths when
they are stroked. Values of LineCap are UndefinedCap, ButtCap,
RoundCap, and SquareCap:</p>
<pre class="literal-block">void            strokeLineCap ( const LineCap lineCap_ )

LineCap         strokeLineCap ( void ) const</pre>
</section>
<section id="strokelinejoin">
<h2><a class="toc-backref" href="#toc-entry-194" role="doc-backlink">strokeLineJoin</a></h2>
<p>Specify the shape to be used at the corners of paths (or other
vector shapes) when they are stroked. Values of LineJoin are
UndefinedJoin, MiterJoin, RoundJoin, and BevelJoin:</p>
<pre class="literal-block">void            strokeLineJoin ( const LineJoin lineJoin_ )

LineJoin        strokeLineJoin ( void ) const</pre>
</section>
<section id="strokemiterlimit">
<h2><a class="toc-backref" href="#toc-entry-195" role="doc-backlink">strokeMiterLimit</a></h2>
<p>Specify miter limit. When two line segments meet at a sharp
angle and miter joins have been specified for 'lineJoin', it is
possible for the miter to extend far beyond the thickness of
the line stroking the path. The miterLimit' imposes a limit on
the ratio of the miter length to the 'lineWidth'. The default
value of this parameter is 4:</p>
<pre class="literal-block">void            strokeMiterLimit ( const unsigned int miterLimit_ )

unsigned int    strokeMiterLimit ( void ) const</pre>
</section>
<section id="strokepattern">
<h2><a class="toc-backref" href="#toc-entry-196" role="doc-backlink">strokePattern</a></h2>
<p>Pattern image to use while stroking object outlines:</p>
<pre class="literal-block">void            strokePattern ( const Image &amp;strokePattern_ )

Image           strokePattern ( void  ) const</pre>
</section>
<section id="strokewidth">
<h2><a class="toc-backref" href="#toc-entry-197" role="doc-backlink">strokeWidth</a></h2>
<p>Stroke width for drawing vector objects (default one):</p>
<pre class="literal-block">void            strokeWidth ( const double strokeWidth_ )

double          strokeWidth ( void ) const</pre>
</section>
<section id="subimage">
<h2><a class="toc-backref" href="#toc-entry-198" role="doc-backlink">subImage</a></h2>
<p>Subimage of an image sequence:</p>
<pre class="literal-block">void            subImage ( const unsigned int subImage_ )

unsigned int    subImage ( void ) const</pre>
</section>
<section id="subrange">
<h2><a class="toc-backref" href="#toc-entry-199" role="doc-backlink">subRange</a></h2>
<p>Number of images relative to the base image:</p>
<pre class="literal-block">void            subRange ( const unsigned int subRange_ )

unsigned int    subRange ( void ) const</pre>
</section>
<section id="textencoding">
<h2><a class="toc-backref" href="#toc-entry-200" role="doc-backlink">textEncoding</a></h2>
<p>Annotation text encoding (e.g. &quot;UTF-16&quot;):</p>
<pre class="literal-block">void            textEncoding ( const std::string &amp;encoding_ )

std::string     textEncoding ( void ) const</pre>
</section>
<section id="tilename">
<h2><a class="toc-backref" href="#toc-entry-201" role="doc-backlink">tileName</a></h2>
<p>Tile name:</p>
<pre class="literal-block">void            tileName ( const std::string &amp;tileName_ )

std::string     tileName ( void ) const</pre>
</section>
<section id="totalcolors">
<h2><a class="toc-backref" href="#toc-entry-202" role="doc-backlink">totalColors</a></h2>
<p>Number of colors in the image:</p>
<pre class="literal-block">unsigned long   totalColors ( void )</pre>
</section>
<section id="transformorigin">
<h2><a class="toc-backref" href="#toc-entry-203" role="doc-backlink">transformOrigin</a></h2>
<p>Origin of coordinate system to use when annotating with text or drawing:</p>
<pre class="literal-block">void            transformOrigin ( const double x_,const  double y_ )</pre>
</section>
<section id="transformrotation">
<h2><a class="toc-backref" href="#toc-entry-204" role="doc-backlink">transformRotation</a></h2>
<p>Rotation to use when annotating with text or drawing:</p>
<pre class="literal-block">void            transformRotation ( const double angle_ )</pre>
</section>
<section id="transformreset">
<h2><a class="toc-backref" href="#toc-entry-205" role="doc-backlink">transformReset</a></h2>
<p>Reset transformation parameters to default:</p>
<pre class="literal-block">void            transformReset ( void )</pre>
</section>
<section id="transformscale">
<h2><a class="toc-backref" href="#toc-entry-206" role="doc-backlink">transformScale</a></h2>
<p>Scale to use when annotating with text or drawing:</p>
<pre class="literal-block">void            transformScale ( const double sx_, const double sy_ )</pre>
</section>
<section id="transformskewx">
<h2><a class="toc-backref" href="#toc-entry-207" role="doc-backlink">transformSkewX</a></h2>
<p>Skew to use in X axis when annotating with text or drawing:</p>
<pre class="literal-block">void            transformSkewX ( const double skewx_ )</pre>
</section>
<section id="transformskewy">
<h2><a class="toc-backref" href="#toc-entry-208" role="doc-backlink">transformSkewY</a></h2>
<p>Skew to use in Y axis when annotating with text or drawing:</p>
<pre class="literal-block">void            transformSkewY ( const double skewy_ )</pre>
</section>
<section id="verbose">
<h2><a class="toc-backref" href="#toc-entry-209" role="doc-backlink">verbose</a></h2>
<p>Print detailed information about the image:</p>
<pre class="literal-block">void            verbose ( const bool verboseFlag_ )

bool            verbose ( void ) const</pre>
</section>
<section id="view">
<h2><a class="toc-backref" href="#toc-entry-210" role="doc-backlink">view</a></h2>
<p>FlashPix viewing parameters:</p>
<pre class="literal-block">void            view ( const std::string &amp;view_ )

std::string     view ( void ) const</pre>
</section>
<section id="x11display">
<h2><a class="toc-backref" href="#toc-entry-211" role="doc-backlink">x11Display</a></h2>
<p>X11 display to display to, obtain fonts from, or to capture
image from:</p>
<pre class="literal-block">void            x11Display ( const std::string &amp;display_ )

std::string     x11Display ( void ) const</pre>
</section>
<section id="xresolution">
<h2><a class="toc-backref" href="#toc-entry-212" role="doc-backlink">xResolution</a></h2>
<p>x resolution of the image:</p>
<pre class="literal-block">void            xResolution ( const double x_resolution )
double          xResolution ( void ) const</pre>
</section>
<section id="yresolution">
<h2><a class="toc-backref" href="#toc-entry-213" role="doc-backlink">yResolution</a></h2>
<p>y resolution of the image:</p>
<pre class="literal-block">void            yResolution ( const double y_resolution )
double          yResolution ( void ) const</pre>
</section>
</section>
<section id="low-level-image-pixel-access">
<h1><a class="toc-backref" href="#toc-entry-7" role="doc-backlink">Low-Level Image Pixel Access</a></h1>
<p>Image pixels (of type <a class="reference external" href="PixelPacket.html">PixelPacket</a> ) may be accessed directly via
the Image Pixel Cache .  The image pixel cache is a rectangular window
into the actual image pixels (which may be in memory, memory-mapped
from a disk file, or entirely on disk). Two interfaces exist to access
the Image Pixel Cache. The interface described here (part of the Image
class) supports only one view at a time. See the <a class="reference external" href="Pixels.html">Pixels</a> class for a
more abstract interface which supports simultaneous pixel views (up to
the number of rows). As an analogy, the interface described here
relates to the <a class="reference external" href="Pixels.html">Pixels</a> class as stdio's gets() relates to
fgets(). The <a class="reference external" href="Pixels.html">Pixels</a> class provides the more general form of the
interface.</p>
<p>Obtain existing image pixels via getPixels(). Create a new pixel
region using setPixels().</p>
<p>In order to ensure that only the current generation of the image is
modified, the Image's modifyImage() method should be invoked to reduce
the reference count on the underlying image to one. If this is not
done, then it is possible for a previous generation of the image to be
modified due to the use of reference counting when copying or
constructing an Image.</p>
<p>Depending on the capabilities of the operating system, and the
relationship of the window to the image, the pixel cache may be a copy
of the pixels in the selected window, or it may be the actual image
pixels. In any case calling syncPixels() insures that the base image
is updated with the contents of the modified pixel cache. The method
readPixels() supports copying foreign pixel data formats into the
pixel cache according to the QuantumTypes. The method writePixels()
supports copying the pixels in the cache to a foreign pixel
representation according to the format specified by QuantumTypes.</p>
<p>The pixel region is effectively a small image in which the pixels may
be accessed, addressed, and updated, as shown in the following
example:</p>
<p><img alt="pixel_cache" src="Cache.png" /></p>
<pre class="literal-block">// Construct image based on an existing file
Image image(&quot;cow.png&quot;);

// Ensure that there are no other references to this image.
image.modifyImage();

// Set the image type to TrueColor DirectClass representation.
image.type(TrueColorType);

// Request pixel region with size 60x40, and top origin at 20x30
int columns = 60;
PixelPacket *pixel_cache = image.getPixels(20,30,columns,40);

// Set pixel at column 5, and row 10 in the pixel cache to red.
int column = 5;
int row = 10;
PixelPacket *pixel = pixel_cache+row*columns+column;
*pixel = Color(&quot;red&quot;);

// Save changes to underlying image .
image.syncPixels();

 // Save updated image to file.
image.write(&quot;horse.png&quot;);</pre>
<p>The image cache supports the following methods:</p>
<nav class="contents local" id="topic-4">
<ul class="simple">
<li><p><a class="reference internal" href="#getconstpixels" id="toc-entry-214">getConstPixels</a></p></li>
<li><p><a class="reference internal" href="#getindexes" id="toc-entry-215">getIndexes</a></p></li>
<li><p><a class="reference internal" href="#getconstindexes" id="toc-entry-216">getConstIndexes</a></p></li>
<li><p><a class="reference internal" href="#getpixels" id="toc-entry-217">getPixels</a></p></li>
<li><p><a class="reference internal" href="#setpixels" id="toc-entry-218">setPixels</a></p></li>
<li><p><a class="reference internal" href="#syncpixels" id="toc-entry-219">syncPixels</a></p></li>
<li><p><a class="reference internal" href="#readpixels" id="toc-entry-220">readPixels</a></p></li>
<li><p><a class="reference internal" href="#writepixels" id="toc-entry-221">writePixels</a></p></li>
</ul>
</nav>
<section id="getconstpixels">
<h2><a class="toc-backref" href="#toc-entry-214" role="doc-backlink">getConstPixels</a></h2>
<p>Transfers read-only pixels (DirectClass PixelPackets, and IndexPackets
if applicable for the image type) from the image to the pixel cache as
defined by the specified region:</p>
<pre class="literal-block">const PixelPacket* getConstPixels ( const int x_, const int y_,
                                    const unsigned int columns_,
                                    const unsigned int rows_ ) const</pre>
</section>
<section id="getindexes">
<h2><a class="toc-backref" href="#toc-entry-215" role="doc-backlink">getIndexes</a></h2>
<p>Obtain mutable image pixel indexes (valid for PseudoClass images). The
selected region is defined by the prior getPixels(), getConstPixels(),
or setPixels() call:</p>
<pre class="literal-block">IndexPacket* getIndexes ( void )</pre>
</section>
<section id="getconstindexes">
<h2><a class="toc-backref" href="#toc-entry-216" role="doc-backlink">getConstIndexes</a></h2>
<p>Obtain immutable image pixel indexes (valid for PseudoClass
images). The selected region is defined by the prior getPixels(),
getConstPixels(), or setPixels() call:</p>
<pre class="literal-block">const IndexPacket* getConstIndexes ( void ) const</pre>
</section>
<section id="getpixels">
<h2><a class="toc-backref" href="#toc-entry-217" role="doc-backlink">getPixels</a></h2>
<p>Transfers pixels (DirectClass PixelPackets, and IndexPackets if
applicable for the image type) from the image to the pixel cache as
defined by the specified region. Modified pixels may be subsequently
transferred back to the image via syncPixels:</p>
<pre class="literal-block">PixelPacket* getPixels ( const int x_, const int y_,
                         const unsigned int columns_,
                         const unsigned int rows_ )</pre>
</section>
<section id="setpixels">
<h2><a class="toc-backref" href="#toc-entry-218" role="doc-backlink">setPixels</a></h2>
<p>Allocates a pixel cache region to store image pixels as defined by the
region rectangle.  This area is subsequently transferred from the
pixel cache to the image via syncPixels:</p>
<pre class="literal-block">PixelPacket* setPixels ( const int x_, const int y_,
                         const unsigned int columns_,
                         const unsigned int rows_ )</pre>
</section>
<section id="syncpixels">
<h2><a class="toc-backref" href="#toc-entry-219" role="doc-backlink">syncPixels</a></h2>
<p>Transfers the image cache pixels to the image:</p>
<pre class="literal-block">void syncPixels ( void )</pre>
</section>
<section id="readpixels">
<h2><a class="toc-backref" href="#toc-entry-220" role="doc-backlink">readPixels</a></h2>
<p>Transfers one or more pixel components from a buffer or file into the
image pixel cache of an image.  Used to support image decoders:</p>
<pre class="literal-block">void readPixels ( const QuantumType quantum_,
                  const unsigned char *source_ )</pre>
</section>
<section id="writepixels">
<h2><a class="toc-backref" href="#toc-entry-221" role="doc-backlink">writePixels</a></h2>
<p>Transfers one or more pixel components from the image pixel cache to a
buffer or file.  Used to support image encoders:</p>
<pre class="literal-block">void writePixels ( const QuantumType quantum_,
                   unsigned char *destination_ )</pre>
</section>
</section>
<section id="explicit-logging-configuration-and-callbacks">
<h1><a class="toc-backref" href="#toc-entry-8" role="doc-backlink">Explicit Logging Configuration And Callbacks</a></h1>
<p>It is sometimes useful for a program to not have to depend on a
configuration file for configuring logging (&quot;tracing&quot;).  One reason
for this is because until a logging configuration file has been found
and loaded, default logging parameters are used.  Another reason is
that in some configurations, it is useful for each instance of a
program to use its own logging configuration.  To make this possible,
the Magick++ library provides pass-through functions which allow
setting the logging defaults <em>before</em> InitializeMagick() is called.
Setting logging defaults after InitializeMagick() is called has no
purpose since they will not be used.</p>
<p>The following C++ pass-through functions are available&quot;</p>
<section id="setlogdefaulteventtype">
<h2>SetLogDefaultEventType</h2>
<p>Specify default events which will result in a log event (comma-comma-separated list):</p>
<pre class="literal-block">void SetLogDefaultEventType(const std::string &amp;events_)</pre>
</section>
<section id="setlogdefaultgenerations">
<h2>SetLogDefaultGenerations</h2>
<p>Specify default maximum log file generations before overwriting the first name:</p>
<pre class="literal-block">void SetLogDefaultGenerations(const unsigned int generations_)</pre>
</section>
<section id="setlogdefaultlimit">
<h2>SetLogDefaultLimit</h2>
<p>Specify default maximum number of logging events before creating a new log file:</p>
<pre class="literal-block">void SetLogDefaultLimit(const unsigned int limit_)</pre>
</section>
<section id="setlogdefaultfilename">
<h2>SetLogDefaultFileName</h2>
<p>Specify the file name, or file path, to be written to for each log event:</p>
<pre class="literal-block">void SetLogDefaultFileName(const std::string &amp;filename_)</pre>
</section>
<section id="setlogdefaultformat">
<h2>SetLogDefaultFormat</h2>
<p>Specify default log format using the same special format characters used by &quot;log.mgk&quot;:</p>
<pre class="literal-block">void SetLogDefaultFormat(const std::string &amp;format_)</pre>
</section>
<section id="setlogdefaultlogmethod">
<h2>SetLogDefaultLogMethod</h2>
<p>Specify default C-language call-back function to be invoked for each log event:</p>
<pre class="literal-block">void SetLogDefaultLogMethod(const Magick::LogMethod method_)</pre>
<p>Note that it is hoped that better mechanisms will be provided in the future.</p>
</section>
<section id="setlogdefaultoutputtype">
<h2>SetLogDefaultOutputType</h2>
<p>Specify default logging output type/destination:</p>
<pre class="literal-block">void SetLogDefaultOutputType(const Magick::LogOutputType output_type_)</pre>
<p>Available LogOutputType enumerations are DisabledOutput,
UndefinedOutput, StdoutOutput, StderrOutput, XMLFileOutput,
TXTFileOutput, Win32DebugOutput, Win32EventlogOutput, and
MethodOutput.</p>
<p>Copyright  <a class="reference external" href="mailto:bfriesen&#37;&#52;&#48;simple&#46;dallas&#46;tx&#46;us">Bob Friesenhahn</a> 1999 - 2024</p>
</section>
</section>
</main>


<hr class="docutils">
<div class="document">
    <p><a href="../Copyright.html">Copyright</a>  GraphicsMagick Group 2002-2025<!--SPONSOR_LOGO--></p>
</div>

</main>
</body>
</html>
